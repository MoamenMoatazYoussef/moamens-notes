# Java Collections
## Table of Contents

## Prerequisites
- Java Fundamentals course.
- Java Core course.
- Basic knowledge about data structures is a plus.
- Basic knowledge about Big-O notation for performance is a plus.

## Tips
- *sysout* means System.out.println, I'm lazy.
- FIFO means First-in first-out

## Just Use Arrays
**Why don't we just use Arrays to solve our daily Collection or Data Structure problems?**
Look at this code:
``` java
class Product {
    private String name;
    private int weight;

    public Product(String name, int weight) {
        this.name = name;
        this.weight = weight;
    }
}

public class Main {   
    public static void main(String[] args) {
        Product door = new Product("Door", 35);
        Product floorPanel = new Product("Panel", 25);

        Product[] products = { door, floorPanel };

        System.out.println(products);
    }
}
```

You know what the output will be?
It will be like this:
```
[Lcom.monotonic.collections.Product;@18ff79
```
Or something like that. That's weird, and we can't understand anything from it.

We would get a better output by using Arrays.toString():
``` Java
System.out.println(Arrays.toString(products));
```

**What about adding elements to arrays?** <br/>
Look at this code:
``` Java
Product window = new Product("Window", 10);
products[2] = window;

System.out.println(Arrays.toString(products));
```
We'll get an *Exception*, an ArrayIndexOutOfBoundsException specifically.
That's because Arrays don't resize automatically to include new elements, we need to do that manually, like this:
``` Java
Product window = new Product("Window", 10);
Product[] newProducts = Arrays.copyOf(products, products.length + 1);
newProducts[products.length] = window;
products = newProducts;

System.out.println(Arrays.toString(products));
```
The reality, however, is that we've copied the array in a new array that has a length that's bigger by 1, then added the new element.
That means, we'll need to copy arrays every time we add or remove elements.

- What if we don't want duplicates in an Array? we'll need to check that every time we add something to an array.
- What about any constraint we want to apply on arrays? We need to manually implement them and check them in any operation done on arrays.

These reasons make developers carry the weight of implementing their own data structures. There are obviously very common data structures, especially the ones studied in theory. So why not just *make a framework of these data structures* so that they are common and easy to use, and also still make Java portable.

***Note:*** Yes, it might be fun to implement them yourself, you can do that in your own Java projects, but in real-life projects that must conform to deadlines and quality standards, it's better to use the already used and tested Java Collections, to save you time of implementation, testing, debugging, deploying, and a lot more steps in the software development process. (Re-inventing the wheel)

This, plus the cases we explored above, plus many other reasons, are why it's much better to use Java's data structures, called Collections. They are a framework of data structures that ship with the JDK, and they are ***EVERYWHERE*** in any java product.

## The Java Collections Framework
### Collection Interface
The Collection framework consists of two things:
- A set of Interfaces that define the behavior of each data structure.
- A set of Implementations for these interfaces.

Usually the interfaces are used to indicate variable types, so we will explore both Interfaces and Implementations.

An very common example is this:
``` Java
List<Integer> myList = new ArrayList<Integer>();
```
- We defined a variable myList.
- Whose type is *List*
    + *List* is an interface, not an implementation, so we need to use an implementation of List in order to be able to use myList.
- Then we used a popular implementation of *List*, which is *ArrayList*, to assign myList to an implementation.
- Now, we can use myList :smile"
- At the same time, remember that a reference variable of datatype MyClass can point to any MyClass object, or any other class that inherits from MyClass.
- This means that the myList is still a reference to a *List*, not an *ArrayList*.
- So, if there is another implementation (for example, *MyAwesomeList* implements *List*) that you want to use, that implements *List*, you can easily switch it :smile: (This is called the *Programming to Interfaces* design principle).

Any collection interface in Java extends a main interface, the *java.util.Collection* interface.

Popular interfaces that implement *Collection*:
- *List:* the most commonly used collection, they are:
    + Ordered.
    + Indexed.
- *Set* and *SortedSet:* these collections have:
    + Distinct elements.
    + SortedSets are Ordered.
    + The interface SortedSet extends the interface Set.
- *Queue* and *Deque:* they are:
    + *Deque* stands for Double-Ended Queue.
    + Ordered by the order of inserting into them.
        - *Queue* is a FIFO-ordered.
        - *Deque* is a FIFO and LIFO-ordered. (A good use case for *Deque* is implementing a Stack).
- *Map* and *SortedMap:* they are 
    + key/value pairs.
    + SortedMap is Ordered, we can iterate on them.

Implementations for these interfaces:
- List: implemented by *ArrayList* and *LinkedList*.
- Set: *HashSet*.
- SortedSet: *TreeSet*. (It also implements *Set* because *SortedSet* extends *Set*).
- Queue: *PriorityQueue*.
- Deque: *LinkedList* and *ArrayDeque*.
- Map: *HashMap*.
- SortedMap: *TreeMap*.

### How do we pick a data structure to use
Here's a simple flow chart to use.
- Are elements keyed (i.e. are they in key/value pairs) ?
    + Yes: Is order important?
        - Yes: **SortedMap.**
        - No: **Map.**
    + No: Are elements unique?
        - Yes: Is order important?
            + Yes: **SortedSet.**
            + No: **Set.**
        - No: FIFO?
            + Yes: **Queue or Deque.**
            + No: LIFO?
                - Yes: **Deque.**
                - No: **List.**

### Behaviors of Collections
So what are the common behaviors and methods that collections have?
Some of these are:
- Iteration: being able to go over all the elements of a collection.
- Sizing: changing a collection's size.
- Mutation: changing some elements or changing some features of the collection itself, like adding/removing elements.

**Some Behaviors of the *Collection* interface** <br/>
- size(): returns how many elements inside the Collection.
- add(..): adds an element to the Collection.
- remove(..): removes an element from the Collection.
- contains(..): checks if an element is present inside a Collection, returns true if the element is indeed inside the Collection, false otherwise.
 - isEmpty(): checks that the Collection has no elements, returns true if it has no elements, false otherwise.

Check all the behaviors specified by *Collection* here:
https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html

**Iteration** <br/>
There is an interface called *Iterable*, it defines something tha we can iterate over i.e. we can:
- Get an iterator, sort of a pointer or a cursor that can go over all the elements in a collection.
- Use that iterator to go over the elements.

Let's print the elements of a Collection, remember this code:
``` Java
class Product {
    private String name;
    private int weight;

    public Product(String name, int weight) {
        this.name = name;
        this.weight = weight;
    }
}

public class Main {   
    public static void main(String[] args) {
        Product door = new Product("Door", 35);
        Product floorPanel = new Product("Panel", 25);

        Product[] products = { door, floorPanel };

        System.out.println(products);
    }
}
```

We'll change it a bit:
- First, we'll use a Collection variable.
- We'll implement it using ArrayList.
- We'll print the elements if the Collection each in its line.
- We'll use an iterator to do the printing.
Look at this code, read the comments.
``` Java
public class Main {   
    public static void main(String[] args) {
        Product door = new Product("Door", 35);
        Product floorPanel = new Product("Panel", 25);

        // Here, we instantiate a Collection variable
        // And implement it using the concrete implementation ArrayList.
        // Note: it's a generic type, so we give it a type <Product>
        Collection<Product> products = new ArrayList<>();

        // Here, we use Collection's method to add elements to the Collection "products"
        products.add(door);
        products.add(floorPanel);

        // Now to the iterating part.
        // First, we need to make an iterator variable, Iterator is a datatype in Java
        // it's a generic datatype, so we should give it a type to iterate over, which is <Product>
        // Then, we want this iterator to be an iterator of the Collection "products"
        // So, we use Collection's method iterator() to retrieve an iterator of "products"
        // and store it in the variable we just made, so that we can be able to use that iterator.
        final Iterator<Product> productIterator = products.iterator();

        // The Iterator now doesn't point to an element in the collection, but it will point to
        // the first element when we actually use it.

        // Now, to actually use the iterator to loop over the things inside the list
        // we use a loop, but instead of using an index, we use Iterator's method hasNext()
        // a method that returns true of there are elements that we haven't gone over with the Iterator yet
        while(productIterator.hasNext()) {

            // Then, to get the element pointed out by the iterator, we use the next() method
            Product product = productIterator.next();
            System.out.println(product);
        }
    }
}
```

But that's a lot to do, isn't it? <br/>
Don't worry, all that work is bundled in a new loop, a forEach loop, look at this code:
``` Java
public class Main {   
    public static void main(String[] args) {
        Product door = new Product("Door", 35);
        Product floorPanel = new Product("Panel", 25);

        Collection<Product> products = new ArrayList<>();

        products.add(door);
        products.add(floorPanel);

        // Wow, that's a lot easier
        for(Product product: products) {
            System.out.println(product);
        }
    }
}
```

You may have a question, **So why bother using Iterators at all then?** <br/>
The forEach loop is pretty good, but there are *some* things you can do with iterators that you can't do with forEach loop, for example, let's change our use case to this:
- If the product's weight is above 20, print it.
- Else, remove it from the list.
We can do this using an iterator like this:
``` Java
public class Main {   
    public static void main(String[] args) {
        Product door = new Product("Door", 35);
        Product floorPanel = new Product("Panel", 25);

        Collection<Product> products = new ArrayList<>();

        products.add(door);
        products.add(floorPanel);

        final Iterator<Product> productIterator = products.iterator();

        while(productIterator.hasNext()) {

            Product product = productIterator.next();
            if(product.getWeight() > 20) {
                System.out.println(product);
            } else {

                // The iterator method remove() removes the element pointed to by the iterator from the list
                // but don't worry, the iterator still points to the list, and when we use .next() it'll go
                // to the next element, the refernece isn't lost :smile:
                productIterator.remove();
            }
        }
    }
}
```

In the next chapter, we'll examine the main behaviors of each Collection:
- How it works.
- How we can use it.

## Lists
So, what is a list? <br/>
Lists are collections with iteration order, there is an order of iteration that's clearly defined by an index.
We use the index to navigate Lists.
All the APIs of Lists should rely on the index to do any operations.

What are some methods in List that use index?
Let's say we have a List of elements of datatype "E", like:
``` Java
class E { // code }
List<E> myList = new ArrayList<E>();
```
These are some of the methods we can use:
- add(int index, E e): adds the element e at the index *index*.
- remove(int index): removes whatever element at *index*.
- set(int index, E element): updates the elemet at index *index* to be the element *e*.
- addAll(int index, Collection<? extends E> c): adds all elements in the Collection *c* at *index*.
- indexOf(Object o): returns the index of the first element that matches the object *o*.
- lastIndexOf(Object o): returns the index of the last element that matches the object *o*.
- subList(int fromIndex, int toIndex): returns a list of elements starting from the index *fromIndex* to the index *toIndex*. 
    
***Note:*** *fromIndex* is inclusive, *toIndex* is exclusive, so if we do this:
``` Java
List<E> newList = myList.subList(1, 3);
```
newList will contain the elements from myList between indices 1 and 3, it will include:
- myList[1]: this is included because the argument *fromIndex* is inclusive i.e. the element whose index is *fromIndex* is included in the subList.
- myList[2]
That's it, no more elements.

Notice that myList[3] is **Not** included in the sublist, that's because the argument *toIndex* is exclusive i.e. the element whose index is *toList* is **Not** included in the subList.

### ArrayList
This is an array that's backed by a List.
Remember that when we want to add an element to an array we had to copy and do a lot of stuff?
Instead of that, the ArrayList doubles the size of the array when we add things to the array, for example:
- If we have an ArrayList of size 1, and we add an element.
- The size becomes 2, when we add another element.
- The size is doubled to 4.
- Now we can add 2 elements with no resizing, until we fill the 4 spaces.
- Then we add another element, the size jumps to 8.
- Now we can add 3 more elements with no resizing, until we fill the 8 spaces.
- Then we add an element, the size jumps to 16.
- Now we can add 7 more elements with no resizing.
And so on.

As you can see, the resizing is much less frequent in ArrayLists than in plain old arrays.

ArrayLists are good general purpose implementations:
- If you don't know the characteristis of your lists are, just use ArrayList as a default choice.
- They are optimized and efficient.
- Modern CPUs have difficulty because they are so much faster than memory in modern hardware, to compensate for this, they have cache memories to act as intermediate between them and the main memory (the RAM), because ArrayLists are still arrays, the spaces are right next to each other in the memory, so the positions of elements are predict

**Use cases** <br/>
- If you will access and modify existing elements a lot, use ArrayList. 
- If you won't insert or remove elements that much, use ArrayList.

### LinkedList
This is a doubly linked list, with references for the Head and the Tail of the list.
This is really good if we will add and remove elements in the list a lot, because we don't copy anything, we just adjust the references of the elements before and after the new element.

It's slower than ArrayLists because it has to do this reference chasing all the time.

LinkedLists are Lower in performance than ArrayLists in most operations, but they have their use cases.

**Use cases** <br/>
- If we're adding elements at the start very frequently, use LinkedList.
- If you're adding or removing elements very frequently, use LinkedList.

### Performance Comparison between ArrayLists and LinkedLists

![ArrayList VS LinkedList Performance Comparison](https://miro.medium.com/max/904/1*XSFsLZYm0B8UcjztjEbzzA.png "ArrayList VS LinkedList")


Check the full list of behaviors by *List* here:
https://docs.oracle.com/javase/7/docs/api/java/util/List.html