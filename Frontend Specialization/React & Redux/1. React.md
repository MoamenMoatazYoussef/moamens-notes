# The Road To Learn React
## Table of Contents
- [Tips](#tips)
- [Introduction](#introduction)
  * [Installation](#installation)
  * [Contents of a react app](#contents-of-a-react-app)
  * [Introduction to JSX](#introduction-to-jsx)
  * [ReactDOM](#reactdom)
  * [Hot Module Replacement](#hot-module-replacement)
  * [Complex JS in JSX](#complex-js-in-jsx)
  * [How classes are used in React](#how-classes-are-used-in-react)
- [Basics of React](#basics-of-react)
  * [Internal component state](#internal-component-state)
  * [Uniditectional Data Flow](#uniditectional-data-flow)
  * [Event Handlers](#event-handlers)
  * [Interactions with forms and events](#interactions-with-forms-and-events)
  * [Controlled components](#controlled-components)
  * [Split up components](#split-up-components)
  * [Composable Components](#composable-components)
  * [Reusable Components](#reusable-components)
  * [Component Declarations](#component-declarations)
  * [Styling components](#styling-components)
- [Getting Real with an API](#getting-real-with-an-api)
- [Lifecycle and lifecycle methods](#lifecycle-and-lifecycle-methods)
  * [Fetching Data](#fetching-data)
  * [Conditional rendering](#conditional-rendering)
  * [Client- or Server-side search](#client--or-server-side-search)
  * [Paginated Fetch](#paginated-fetch)
  * [Client Cache](#client-cache)
  * [Error Handling](#error-handling)
  * [Axios instead of Fetch](#axios-instead-of-fetch)
  * [Here's our app so far, you can skip this part if you're not confused or you're practicing along](#here-s-our-app-so-far--you-can-skip-this-part-if-you-re-not-confused-or-you-re-practicing-along)
- [Code Organization & Testing](#code-organization---testing)
  * [ES6 Modules](#es6-modules)
  * [Code organization with ES6 modules](#code-organization-with-es6-modules)
  * [Snapshot tests with Jest](#snapshot-tests-with-jest)
  * [Unit Tests with Enzyme](#unit-tests-with-enzyme)
  * [Component Interface with PropTypes](#component-interface-with-proptypes)
- [Advanced React Components](#advanced-react-components)
  * [Ref a DOM element](#ref-a-dom-element)
  * [Loading...](#loading)
  * [Higher-order components](#higher-order-components)
  * [Advanced Sorting and lodash](#advanced-sorting-and-lodash)
- [State Management](#state-management)
  * [Lifting State](#lifting-state)
  * [setState() revisited](#setstate---revisited)
  * [Taming the state](#taming-the-state)
- [Final steps to production](#final-steps-to-production)
  * [Eject](#eject)
  * [Deployment](#deployment)
  * [Last words](#last-words)

<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>

## Tips
- This notes assumes that you are familiar with HTML, CSS, JS ES5 at least, npm, and git.
- This note assumes that you are familiar with JS topics like: IIFEs, modules, scope, closure.
- Anything after >> is a command in a command prompt, terminal, or bash.

## Introduction
Why react?
- SPAs have become popular.
- React is the V in MVC, enables rendering of components, but you can build whole SPAs with React.
- And a lot of other reasons.

### Installation
Step 1: install node (npm comes with node).
Step 2: install git.
Step 3:
    >> npm install -g create-react-app

    This is a zero-config starter kit for react.

Step 4: create a react app:
    >> create-react-app
    

NOTE: there's another way to install react:
>> nom install react react-dom
This command adds react to a project, but you need to configure Babel yourself, I'll search why and when this method would be preferred.

### Contents of a react app
my-app contains the following files/folders:
    - README.md: this is pre-generated by create-react-app, you can change it to describe your app afterwards.
    - node_modules: a folder containing all node packages installed by npm. (Usually you won't touch this folder, but install stuff by npm commands)
    - package.json: a file showing a list of node package dependencies and other configs.
    - .gitignore: the file that indicates which files should NOT be added to your git repo.
    - src: welcome to the folder where you'll be developing inside.
        - App.test.js: a file for your tests.
        - index.js: a starting file.
        - index.css.
        - App.css.
    - public: this folder has all YOUR files when building for PRODUCTION, this will have the files from src folder built and bundles into it.
    - other files, leave them for now.

### Introduction to JSX
JSX is the syntax used in React, JSX is JS.
Open the src/App.js and you will fine a boilerplate code written in JSX,
the code inside is a JSX code, but it's familiar because JSX is JS.
Here's the code:
``` JSX
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
    render() {
        return (
            <div className="App">
                <header className="App-header">
                    <img src={logo} className="App-logo" alt="logo" />
                    <h1 className="App-title">Welcome to React</h1>
                </header>
                <p className="App-intro">
                    To get started, edit <code>src/App.js</code> and save to reload.
                </p>
            </div>
        );
    }
}

export default App;
```

- import and export are ES6 syntax, we'll see them later.
- First, we have a React ES6 class whose name is App, so this is a component declaration.
    We can instantiate it and use it everywhere in our application. 
    We do that with adding this:
    ``` HTML
        <App />
    ```
- This class returns an HTML element that will be rendered, specified in the render() function.
- Inside the render function we see something that looks very similar to HTML, but it's not.
    Here comes JSX, JSX lets us mix HTML and JS.

To make things simpler, we'll remove the JSX inside and write basic HTML:
``` JSX 
import React, { Component } from 'react';
import './App.css';

class App extends Component {
    renter() {
        return (
            <div className="App">
                <h2>Freedom</h2>
            </div>
        );
    }
}

export default App;
```

We can only return HTML in our render(), we can't put JS in there but we can put JS variables containing data or HTML, in curly braces:
``` JSX
import React, { Component } from 'react';
import './App.css';

class App extends Component {
    renter() {
        var bestScout = 'levi';
        return (
            <div className="App">
                <h2> { bestScout } </h2>
            </div>
        );
    }
}

export default App;
```

Notive that div has a className attribute, it reflects the 'class' attribute in HTML.
Because of technical reasons, JSX replaces some HTML internal attributes with their own.

### ReactDOM
So, where is our app component used?
In src/index.js:
``` JSX
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import './index.css';

ReactDOM.render(
    <App />,
    document.getElementById('root')
);
```

This global object ReactDOM has a function render(), it takes a DOM node in the HTML and replace it with the JSX.
We can use this function many times, this is why React is easy to integrate with foreign apps.
It accepts two args:
    - The JSX that gets rendered.
    - The place in HTML where we will hook our React app, which should have id="root", that is found in public/index.html.
You can pass your App component to the function, but we can also pass any JSX as long as it's a JSX.

### Hot Module Replacement
It's something we can do to make life for us developers easier, it's entirely optional but consider it anyway.
Hot Module Replacement (HMR): a tool to reload your app in the browser, in the code in src/index.js:
``` JSX
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import './index.css';

ReactDOM.render(
    <App />,
    document.getElementById('root');
);

if (module.hot) {
    module.hot.accept();
}
```

The browser will NOT refresh, but will display the correct output.
Why this is good:
- Debugging: instead of reloading and seeing console.log, you use this as it auto changes without refresh.
- HMR keeps the app state wherever it is, also helps in debugging.

### Complex JS in JSX
Let's render a list of items in our app:
``` JSX
import React, { Component } from 'react';
import './App.css';

const list = [
    {
        name: 'rick',
        ID: 1
    },
    {
        name: 'daryl',
        ID: 2
    },
    {
        name: 'carol':
        ID: 3
    },
    {
        name: 'carl':
        ID: 4
    }
]; //notice that this data reflects data you'll get from Fetching from an API.

//Now, to render all of them, we'll use the map() function built-in JS
class App extends Component {
    render() {
        return(
            <div className="App">
                { //this is because we'll put a variable inside here
                    list.map(function(item) {
                        return <div>{item.name}</div>
                    })
                }
            </div>
        );
    }
}

export default App;
```

As you can see, using JS inside HTML is really powerful in JSX.
React will render every item, but we should add one helper for React to improve performance: 
assign a key attribute to each list element, so that React can identify added, changed, and removed items when the list changes:
``` JSX part of the above code
class App extends Component {
    render() {
        return(
            <div className="App">
                { //this is because we'll put a variable inside here
                    list.map(function(item) {
                        return (
                            <div key={item.ID}> //here is the change we've made
                                {item.name}
                            </div>
                        );
                    })
                }
            </div>
        );
    }
}
```

Make sure that the key attribute is a STABLE IDENTIFIER i.e. will stay unique no matter how the array changes, do not use the index of the item in the array.


### How classes are used in React
The App class extends Component.
The Component class encapsulates all implementation of a React component.
These methods are a public interface, one of them has to be overridden 'render()', others don't need to.

## Basics of React
So far we've learned basic basics of react and how to set it up, now we'll dive deeper.

### Internal component state
This is a variable kept in any React component that allows us to save, modify, and delete properties stored in the component, they are usually a list of items.
They can be initialized using a constructor:
``` JSX
const list = [
    {
        title: 'the walking dead',
        protaganist: 'rick grimes',
        seasons: 10
    },
    ...
];

class App extends Component {
    constructor(props) {
        super(props);

        this.state = {
            list: list
        };
    }
    ...
}
```
We always have to call super() in any React Component's constructor (or constructor of any class that extends it).
Of course, we can access the local state using "this" e.g. we can use it in render().
Now the list resides in the internal component state, we can add, change, and remove items from it, every time the state is changed, the render() method runs again.
BUT DO NOT CHANGE THE STATE DIRECTLY, use setState() instead.

### Uniditectional Data Flow
We will make some components interact with each other so that we can try to change the internal state through components.
For example, we'll make a list of stuff with buttons, when we click a button, the item with the button disappears.
``` JSX
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

const list = [
  {
      id: 1,
      title: 'the walking dead',
      protaganist: 'rick grimes',
  },
  {
    id: 2,
    title: 'attack on titan',
    protaganist: 'eren jeager',
    seasons: 3
  }
];

class App extends Component {
  constructor() {
    super();
    this.state = {
      list,
    };
    this.onDismiss = this.onDismiss.bind(this); //this is done to define onDismiss as a class method only accessible via the class.
  }

  onDismiss(id) {
      const isNotId = item => item.id !== id; //arrow function
      const updatedList = this.state.list.filter(isNotId); //we're using filter() built-in function in JS to just get any items other than the one we want to delete.
      
      //This is the part where state is manipulated:
      this.setState({
          list: updatedList
      });
  }

  render() {
    return (
      <div className="App">
       {this.state.list.map(item =>
          <div key={item.id}>
            <span>{item.title} - </span>
            <span>{item.protaganist}</span>
            <span>
              <button
                onClick={() => this.onDismiss(item.id)}
                type="button">
                Dismiss
              </button>
            </span>
          </div>
        )}
      </div>
    );
  }
}

export default App;
```

The onDismiss function in the onClick handler is an ARROW function enclosed by another function, that way we can use item.id to identify the item that will be dismissed.
What we just did is called 'unidirectional data flow', where an action triggers a function or class method that modifies the internal state, then the render() function runs again.

To bind onDismiss to the class, we used hard binding using bind().
Don't define business logic inside the constructor to avoid using bind, define business logic outside in separate functions then bind those functions in the constructor normally.

Note: ES6 by default binds any defined ARROW functions to the class they were defined inside:
``` ES6
class Whatever {
    myFunction = () => {
        //code
    }; //now we don't have to bind it using bind()

    ...
}
```
React documentation uses this method to bind functions to classes, if you don't like it that's fine, but knowing it will help in reading docs.

### Event Handlers
Passing an executed function to onClick directly usually executes immediately when the application is opened in your browser, this is why we didn't do this:
``` JSX
<button
onClick={this.onDismiss(item.objectID)} //we didn't do this: we didn't pass this.onDismiss() to be executed.
type="button">
    Dismiss
</button>
```

Instead, we wrapped the passed function into another function DEFINITION:
``` JSX
<button
onClick={() => this.onDismiss(item.objectID)} //see? we wrapped it in an arrow function then passed the wrapping function, of course the wrapper function doesn't have to be arrow.
type="button">
    Dismiss
</button>
```

Note: doing this means that the wrapper function will be instantiated every time, this 'can' affect performance if we're working with a huge table of data or something. This isn't usually an issue, but it can be.

### Interactions with forms and events
Let's add another functionality to our application, we'll add sort of a search functionality that filters our list based on what we search for.
``` JSX
render() {
    return (
      <div className="App">
        <form> //this is the new part we've added
            <input type="text" />
        </form>
       {this.state.list.map(item =>
       ...
       )}
       </div>
    );
}
```
To implement the search functionality, we need to store the value of input in our local state, to do this first we define a handler onChange:
``` JSX
render() {
    return (
      <div className="App">
        <form> //this is the new part we've added
            <input type="text"
            onChange={this.onSearchChange}
            />
        </form>
       {this.state.list.map(item =>
       ...
       )}
       </div>
    );
}
```

Now we'll implement the searching function itself, remember to bind onSearchChange in the constructor of the class:
``` JSX
class App extends component {
    constructor() {
        super();
        this.state = {
            list,
            searchTerm: '' //this is an initial value for searchTerm, which is used in onSearchChange
        };
        this.onDismiss = this.onDismiss.bind(this);
        this.onSearchChange = this.onSearchChange.bind(this);
    }
    ...

    onSearchChange(event) { //When using a handler in our element, we can pass the React event triggered itself just like normal JS.
        this.setState({
            searchTerm: event.target.value
        });
    }
}
```

Note: this.setState() is a shallow merge, it preserves other properties if they're not updated, so we don't need to pass the previous list to it every time.

We haven't yet implemented the searching, but we can use searchTerm to 'temporarily' filter the list, this is done in the render() method, before we map over the list we apply a filter on it.
We can't do what we did in onDismiss because this filtering is temporary, we don't want to change the internal list itself.
``` JSX
render() {
    return (
      <div className="App">
        <form> //this is the new part we've added
            <input type="text"
            onChange={this.onSearchChange}
            />
        </form>
       {this.state.list.filter(ourSearchFunction).map(item => //HERE, the filter is added BEFORE the map
       ...
       )}
       </div>
    );
}
```

Now we need to implement ourSearchFunction, we will define it OUTSIDE our class, but this means it can't access searchTerm or state, so we need to pass it and return a new function to evaluate the filter condition we want.
Let's call the function isSearched:
``` JSX
function isSearched(searchTerm) {
    return function(item) { //the big function returns another function, this will be used in the filter
        return item.name.toLowerCase().includes(searchTerm.toLowerCase());
    }
}
```
We used an includes() function, which is ES6

Of course, we can make it super concise by doing this:
``` JSX
const isSearched = searchTerm => item => item.name.toLowerCase().includes(searchTerm.toLowerCase());
```

Remember that this function is defined OUTSIDE the class.
Now we'll use this filter in our render function:
``` JSX
render() {
    return (
      <div className="App">
        <form> //this is the new part we've added
            <input type="text"
            onChange={this.onSearchChange}
            />
        </form>
        {this.state.list
            .filter(isSearched(this.state.searchTerm))
            .map(item => //HERE, the filter is added BEFORE the map
        ...
        )}
        </div>
    );
}
```

The search functionality should work now, here is the full code:
``` JSX
import React, { Component } from 'react';
// import logo from './logo.svg';
import './App.css';

const list = [
  {
      id: 1,
      title: 'the walking dead',
      protaganist: 'rick grimes',
  },
  {
    id: 2,
    title: 'attack on titan',
    protaganist: 'eren jeager',
    seasons: 3
  }
];

class App extends Component {
    constructor() {
        super();
        this.state = {
            list,
            searchTerm: ''
        };
        this.onDismiss = this.onDismiss.bind(this);
        this.onSearchChange = this.onSearchChange.bind(this);
    }

    onSearchChange(event) {
        this.setState({
            searchTerm: event.target.value
        });
    }

  onDismiss(id) {
      const isNotId = item => item.id !== id;
      const updatedList = this.state.list.filter(isNotId);
      this.setState({
          list: updatedList
      });
  }

  render() {
    return (
      <div className="App">
        <form>
            <input type="text"
            onChange={this.onSearchChange}
            />
        </form>
        {this.state.list.filter(isSearched(this.state.searchTerm)).map(item =>
          <div key={item.id}>
            <span>{item.title} - </span>
            <span>{item.protaganist}</span>
            <span>
              <button
                onClick={() => this.onDismiss(item.id)}
                type="button">
                Dismiss
              </button>
            </span>
          </div>
        )}
      </div>
    );
  }
}

const isSearched = searchTerm => item => item.title.toLowerCase().includes(searchTerm.toLowerCase());

export default App;
```

### Controlled Components
Form elements like input, textarea, select hold their own state in plain HTML e.g. the value attribute.
They modify that value internally if someone changes it from the outside, this is called an Uncontrolled Component, becuase it handles its own state. <br/>

In React, we need our elements to be Controlled Components.
We do that by setting these states manually e.g. in the previous code:
``` JSX
...
render() {
    return(
        <div className="App">
            <form>
                <input type="text"
                value={searchTerm} //see, here we set it manually
                onChange={this.onSearchChange}
                />
            </form>
        ...
        </div>
    );
}
...
```

### Split up components
This is the last code we've done:
``` JSX
import React, { Component } from 'react';
// import logo from './logo.svg';
import './App.css';

const list = [
  {
      id: 1,
      title: 'the walking dead',
      protaganist: 'rick grimes',
  },
  {
    id: 2,
    title: 'attack on titan',
    protaganist: 'eren jeager',
    seasons: 3
  }
];

class App extends Component {
    constructor() {
        super();
        this.state = {
            list,
            searchTerm: ''
        };
        this.onDismiss = this.onDismiss.bind(this);
        this.onSearchChange = this.onSearchChange.bind(this);
    }

    onSearchChange(event) {
        this.setState({
            searchTerm: event.target.value
        });
    }

  onDismiss(id) {
      const isNotId = item => item.id !== id;
      const updatedList = this.state.list.filter(isNotId);
      this.setState({
          list: updatedList
      });
  }

  render() {
    return (
      <div className="App">
        <form>
            <input type="text"
            onChange={this.onSearchChange}
            />
        </form>
        {this.state.list.filter(isSearched(this.state.searchTerm)).map(item =>
          <div key={item.id}>
            <span>{item.title} - </span>
            <span>{item.protaganist}</span>
            <span>
              <button
                onClick={() => this.onDismiss(item.id)}
                type="button">
                Dismiss
              </button>
            </span>
          </div>
        )}
      </div>
    );
  }
}

const isSearched = searchTerm => item => item.title.toLowerCase().includes(searchTerm.toLowerCase());

export default App;
```

As you can see, we have one component that's really big, why not split that into smaller components?
We'll start with:
- a component for search input.
- a component for the list.
Now, first of all the render function in App will change:
``` JSX
class App extends Component {
    ...
    render() {
        const {searchTerm, list} = this.state;
        return(
            <div className="App">
                <Search />
                <Table />
            </div>
        )
    }
}
```

We can pass properties to components:
``` JSX
class App extends Component {
    ...
    render() {
        const {searchTerm, list} = this.state;
        return(
            <div className="App">
                <Search
                    value={searchTerm}
                    onChange={this.onSearchChange}
                />
                <Table 
                    list={list}
                    pattern={searchTerm}
                    onDismiss={this.onDismiss}
                />
            </div>
        )
    }
}
```

Now, we define the other two components:
``` JSX
class App extends Component {
    ...
    render() {
        const {searchTerm, list} = this.state;
        return(
            <div className="App">
                <Search
                    value={searchTerm}
                    onChange={this.onSearchChange}
                />
                <Table 
                    list={list}
                    pattern={searchTerm}
                    onDismiss={this.onDismiss}
                />
            </div>
        )
    }
}

class Search extends Component {
    render() {
        const { value, onChange } = this.props;
        return (
            <form>
                <input type="text"
                value={value}
                onChange={onChange}
            />
            </form>
        );
    }
}

class Table extends Component {
    render() {
        const { list, pattern, onDismiss } = this.props;
        return (
            {list.filter(isSearched(pattern)).map(item =>
                <div key={item.id}>
                    <span>{item.title} - </span>
                    <span>{item.protaganist}</span>
                    <span>
                        <button
                        onClick={() => onDismiss(item.id)}
                        type="button">
                            Dismiss
                        </button>
                    </span>
                </div>
            )}
        );
    }
}
```

Now the code is modularized a bit:
``` JSX
import React, { Component } from 'react';
// import logo from './logo.svg';
import './App.css';

const list = [
  {
      id: 1,
      title: 'the walking dead',
      protaganist: 'rick grimes',
  },
  {
    id: 2,
    title: 'attack on titan',
    protaganist: 'eren jeager',
    seasons: 3
  }
];

class App extends Component {
    constructor() {
        super();
        this.state = {
            list,
            searchTerm: ''
        };
        this.onDismiss = this.onDismiss.bind(this);
        this.onSearchChange = this.onSearchChange.bind(this);
    }

    onSearchChange(event) {
        this.setState({
            searchTerm: event.target.value
        });
    }

  onDismiss(id) {
      const isNotId = item => item.id !== id;
      const updatedList = this.state.list.filter(isNotId);
      this.setState({
          list: updatedList
      });
  }

  render() {
    const {searchTerm, list} = this.state;
    return(
        <div className="App">
            <Search
                value={searchTerm}
                onChange={this.onSearchChange}
            />
            <Table 
                list={list}
                pattern={searchTerm}
                onDismiss={this.onDismiss}
            />
        </div>
    )
}
}

class Search extends Component {
render() {
    const { value, onChange } = this.props;
    return (
        <form>
            <input type="text"
            value={value}
            onChange={onChange}
        />
        </form>
    );
}
}

class Table extends Component {
render() {
    const { list, pattern, onDismiss } = this.props;
    return (
      <div>
        {list.filter(isSearched(pattern)).map(item =>
            <div key={item.id}>
                <span>{item.title} - </span>
                <span>{item.protaganist}</span>
                <span>
                    <button
                    onClick={() => onDismiss(item.id)}
                    type="button">
                        Dismiss
                    </button>
                </span>
            </div>
        )}
      </div>
    );
}
}

const isSearched = searchTerm => item => item.title.toLowerCase().includes(searchTerm.toLowerCase());

export default App;
```

Notice that we've used this.props to access the properties we passed in the App component's render function.

### Composable Components
There's a property in the this.props: children, this can be used to pass HTML and text elements to the components from above.
Like this:
``` JSX
class App extends Component {
    ...
    render() {
        const {searchTerm, list} = this.state;
        return(
            <div className="App">
                <Search
                    value={searchTerm}
                    onChange={this.onSearchChange}
                >
                Write your search pattern here //See this here?
                </Search>
                <Table 
                    list={list}
                    pattern={searchTerm}
                    onDismiss={this.onDismiss}
                />
            </div>
        )
    }
}
```

The text added INSIDE the Search component can be accessed via the this.children property.
This allows us to compose elements of each other and we can plug them into each other like legos.

### Reusable Components
Of course as we've seen, classes promote reusability of components.
To further increase reusability we can wrap normal HTML elements into components like this:
``` JSX
class Button extends Component {
    render() {
        const {
            onClick,
            className = '', //Default value in case no class is passed.
            children
        } = this.props;

        return (
            <button
                onClick={onClick}
                className={className}
                type="button">
                {children}
            </button>
        );
    }
}
```

It might seem redundant to do this, but now we can just use as many Buttons as we can without needing to rewrite the <button> element.
Plus modifying the class ensures that all Buttons adapt to the modifications.

### Component Declarations
There are different types of components in React:
- Functional Stateless Components:
    These are FUNCTIONS (hence, functional), they get an input, the return an output.
    Inputs are props, output is a component instance i.e. JSX.
    They have no local state (hence, stateless).
    There is no "this" object.
    There is no lifecycle methods e.g. constructor, render. (We'll explore lifecycle methods later)
- ES6 Class Components:
    What we used so far.
    They extend Component.
    They have all lifecycle methods (inherited from Component).
    They have local state.
    etc.
- React.createClass: this was used in ES5 to declare components, but it's deprecated now, don't use it.

When to use each?
    Ask yourself:
        - Do you need local state?
        - Do you need lifecycle methods?
        If both are NO, use functional stateless components,
        Else use ES6 class components.

    So usually in development you begin by declaring components as functional stateless components, once you find you need access to state or lifecycle, refactor them to ES6.

==> AUTHOR'S NOTE: I'll start writing FSC instead of "functional stateless components" because I'm lazy, but it's not an official abbreviation or anything.

In our example, Search and Table don't need state or lifecycle, so, we can refactor them to FSC:
``` JSX
function Search(props) {
    const { value, onChange } = props;
    return (
        <form>
            <input type="text"
            value={value}
            onChange={onChange}
        />
        </form>
    );
}
```

We can even put the destructing in the function signature itself:
``` JSX
function Search({ value, onChange }) {
    return (
        <form>
            <input type="text"
            value={value}
            onChange={onChange}
        />
        </form>
    );
}
```

Even better, arrow functions:
``` JSX
const Search = ({ value, onChange }) =>
    <form>
        <input type="text"
        value={value}
        onChange={onChange}
    />
    </form>
    ;
```

And here's Table after refactoring it to FSC:
``` JSX
const Table = ({ list, pattern, onDismiss }) =>
      <div>
        {list.filter(isSearched(pattern)).map(item =>
            <div key={item.id}>
                <span>{item.title} - </span>
                <span>{item.protaganist}</span>
                <span>
                    <button
                    onClick={() => onDismiss(item.id)}
                    type="button">
                        Dismiss
                    </button>
                </span>
            </div>
        )}
      </div>
    ;
```

### Styling components
To add styles we use src/App.css and src/index.css
Of course, you can add inline CSS into JSX, into the HTML itself.

## Getting Real with an API
In this chapter we'll discuss how to use react with APIs, now we're not going about sample data anymore, we'll fetch data from an API.

Each React (ES6 components not FSCs) component has a lifecycle, which is some 'stages' the component goes through as the app is running.
Each stage has some functions hooked to it, these are called Lifecycle Methods.

We need to know the lifecycle of a React Component, then we need to know the lifecycle methods, then we can interact with an API.

## Lifecycle and lifecycle methods
A) Phase 1: Creation of a component
    1) creating an instance of a component. 
        Lifecycle methods associated with this stage:
        - constructor(), called when a new instance is created and initialized, we can set an initial state and bind class methods.
    2) inserting the component into the DOM (This process is called 'mounting'). 
        Lifecycle methods associated with this stage:
        - componentWillMount(): this is called just after the constructor, just before we actually mount the component.
        - render(): This is called TO MOUNT the component, and we know this already. (Also called when state or props of a component change.)
        - componentDidMount(): This is called after mounting has finished i.e. after render().

    So, order of function calls when a component is created and mounted:
        constructor(); //initialization + we can set an initial state and bind class methods
        componentWillMount(); //we can set states here since it won't trigger a second rendering, but it's recommended to do it in the constructor anyway.
        render(); //returns elements as output of the component, it should be pure and not modify component state, it just gets state and props.
        componentDidMount(); //called once when the component is mounted, here is the best place to do async fetch from and API.

B) Updating a component i.e. state/props changed.
    order of calls when an update happens:
        componentWillReceiveProps(nextProps); //Here we can set state based on new props, or do other stuff as well.
        shouldComponentUpdate(); //if props or state change, this is called, this returns boolean that decide if we'll re-render the component or not, useful for performance optimizations.
        componentWillUpdate(); //invoked before render, we can do stuff here last time before render.
        render(); //you know who I am
        componentDidUpdate(); //invoked just after render, you can perform DOM operations or async fetches here.

        NOTE: we can't trigger setState here, if we want to change state we'll have to do that inside componentWillReceiveProps.

C) Unmounting a component:
    Only one function:
        componentWillUnmount(); //it's like a destructor, called just before you destroy the component, used to perform any clean-up tasks.

D) Error: (introduced in React 16)
    Only one function too:
        componentDidCatch(error, info); //this is used to catch errors in components.

        For example, if we want to render a list, but the local state list is set to null (because API fetch failed or whatever), we can throw the error and catch it in componentDidCatch, we can store the error in the local state and show optional messages or whatever.

### Fetching Data
We'll use the native Fetch API in JS to fetch data, and we'll do the fetching inside componentDidMount.
Our API url is 'https://hn.algolia.com/api/v1/search?query=redux'
Now, a quick tip is to 'split' your request URL into variables so that it's easy to change them later by you or another developer if the API changes or request has params, like this:
``` JSX
const PATH_BASE     = 'https://hn.algolia.com/api/v1';
const PATH_SEARCH   = '/search';
const PARAM_SEARCH  = 'query=';
const DEFAULT_QUERY = 'redux';

const url = `${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${DEFAULT_QUERY}`;
```

That will keep the url component flexible in the future.
Now to do the actual fetching, let's break it into steps:
- Step 1: fetch data in componentDidMount.
- Step 2: change the state in the component using the result fetched.
- Step 3: finalizing what we did.

Note: before we do this, we can remove the old local list since now we'll get data from an API.

Step 1:
``` JSX
class App extends Component {
  constructor(props) {
    ...
  }

  componentDidMount() {
    const { searchTerm } = this.state;
    fetch(`${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}`) //this is the native fetch API for JS
      .then(response => response.json())                             //then we get response in JSON format
      .then(result => this.doSomethingWithResult(result))              //then we invoke this method, which uses the results to change the state, but it's not implemented yet.
      .catch(error => error);
  }

  ...
  render() {
      ...
  }
}
```

Step 2: implement the doSomethingWithResult method, we'll change its name to setSearchTopStories for this example:
``` JSX
class App extends Component {
  constructor(props) {
    ...
  }

  setSearchTopStories(result) {
    this.setState({
      result
      }); //state changed, so render will be called and get the new data.
  }

  componentDidMount() {
    const { searchTerm } = this.state;
    fetch(`${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}`) //this is the native fetch API for JS
      .then(response => response.json())                             //then we get response in JSON format
      .then(result => this.doSomethingWithResult(result))              //then we invoke this method, which uses the results to change the state, but it's not implemented yet.
      .catch(error => error);
  }

  ...
  render() {
      ...
  }
}
```

Step 3: finalizing, which means:
  - binding the new method to the class in the constructor,
  - adding necessary properties to the local state,
  - removing 'list' from our component and substituting it with 'result'
  Note: the JSON object returned by the API is not a simple list, it's a complex object, so we'll need to investigate it to know how to get our data.
    in our example, we need to get result.hits in order to get our list of data.
``` JSX
class App extends Component {
  constructor(props) {
    super(props);
    this.state = {
      result: null,             //Step 3: we added this
      searchTerm: DEFAULT_QUERY //Step 3: we added this
    };

    this.setSearchTopStories = this.setSearchTopStories.bind(this); //Step 3: we bound the method to the class
    this.onDismiss = this.onDismiss.bind(this);
    this.onSearchChange = this.onSearchChange.bind(this);
  }

  // Lifecycle methods
  componentDidMount() { //Step 1
    const { searchTerm } = this.state;
    fetch(`${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}`)
      .then(response => response.json())
      .then(result => this.setSearchTopStories(result))
      .catch(error => error);
  }

  setSearchTopStories(result) { //Step 2
    this.setState({
      result
      }); //state changed, so render will be called and get the new data.
  }

  ....

  render() {
    const { searchTerm, result } = this.state; //Step 3: we changed list to result

    if(!result) { //Step 3: we added this check in order to avoid errors if there's nothing returned by the API
      return null; //you can return null from render(), that causes the component to display nothing.
    }
    
    return (
      <div className="App">
        <Search value={searchTerm} onChange={this.onSearchChange} />
        <Table list={result.hits} pattern={searchTerm} onDismiss={this.onDismiss} />  //Step 3: result.hits
      </div>
    );
  }
}
```

What did we just do?
- Now, our component's initial state has an empty result and a default search term.
- So, when the componentDidMount method is called, the fetch will use the default search term 'redux'.

Note: you can use other fetch APIs like axios, superagent, etc.

But also, if you notice, there are some bugs in the app now:
- Dismiss button doesn't work, gives an error.
- When you search, the search is applied on the list you fetched, that was already filtered by another search term in the request i.e. when you search, the results displayed will only be from THAT list in front of you.

These bugs are called Regression Bugs (features that stop functioning properly after a certain event e.g. system upgrade, change in daylight saving time, system patching, etc.).


Bug 1: the Dismiss button.
  What happened?
    the onDismiss method isn't aware of the complex result object, it only knows a list in the local state.
  Solution?
    Make it operate on the result object itself, 
       const updatedHits = this.state.result.hits.filter(isNotId); 
    but now setState is only aware of result.hits and doesn't change local list except if result object is changed.
    We can mutate the result.hits list, but this is not recommended since React embraces immutable data structs.
    We can generate a new object based on the info we have, we can use Object.assign(target, ...sources) 
    ``` JSX
    const updatedHits   = { hits: updatedHits };
    const updatedResult = Object.assign({}, this.state.result, updatedHits);
    ```
    Now, source objects will merge such that latter objects override former objects if they share the same props i.e. new result will override old result in state, but without mutating any of them, and both will be put in an empty target object.
    We can also use the spread operator like this:
    ``` JSX
    const updatedResult = {...this.state.result, hits: updatedHits };
    ```

  So, the final result is:
  ``` JSX
    onDismiss(id) {
      const isNotId = item => item.objectID !== id;
      const updatedHits = this.state.result.hits.filter(isNotId);
      this.setState({
        result: { ...this.state.result, hits: updatedHits }
      });
    }
  ```
  
  Note: change all item.id to item.objectID since this is the name of the id prop in the objects retrieved from the API, inside result.hits.

### Conditional rendering
You can make the decision to render an element or another, or none at all.
One simple example is the if condition we added in the render() method as a check.
We can apply this on the Table component, where we ONLY wrap it in a condition so that it's displayed ONLY if there's results, but the rest should render even if the result is null, like this:
``` JSX
render() {
    const { searchTerm, result } = this.state;
    return (
      <div className="App">
        <Search value={searchTerm} onChange={this.onSearchChange} />
        {result ? //we used the ternary operator
        <Table
          list={result.hits}
          pattern={searchTerm}
          onDismiss={this.onDismiss}
        />
        : null }
      </div>
    );
  }
```

Another way to do this is using && operator, in JS if we do this:
  true && 'hot diggity dog';
the result will always be 'hot diggity dog', while if we do this:
  false && 'hot diggity dog';
the result will always be false.
So, applying this:
``` JSX
render() {
    const { searchTerm, result } = this.state;
    return (
      <div className="App">
        <Search value={searchTerm} onChange={this.onSearchChange} />
        {result &&
        <Table
          list={result.hits}
          pattern={searchTerm}
          onDismiss={this.onDismiss}
        />
        }
      </div>
    );
  }
```

You can check out a lot of other conditional rendering approaches.

### Client- or Server-side search
Bug 2:
  What happened?
    The search is applied on client-side, so it searches through the list we fetched which was already filtered by another seaerchTerm.
  Solution:
    Apply the new search term on Server-side.
    Let's define a function onSearchSubmit that fetches results from the API whenever we execute a search:
    ``` JSX
    onSearchSubmit() {
      const { searchTerm } = this.state;
    }
    ```
    This method should use the same functionality as the componentDidMount, but with the new search term.
    So, we can extract the fetch as a reusable component in a separate function:
    ``` JSX
    fetchSearchTopStories(searchTerm) {
      fetch(`${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}`)
      .then(response => response.json())
      .then(result => this.setSearchTopStories(result))
      .catch(error => error);
    }

    componentDidMount() {
      const { searchTerm } = this.state;
      this.fetchSearchTopStories(searchTerm);
    }

    onSearchSubmit() {
      const { searchTerm } = this.state;
      this.fetchSearchTopStories(searchTerm);
    }
    ```

    Now, we'll add a button that onClick executes the onSearchSubmit since we don't want every single change in the search term to trigger a fetch.
    Alternatively, we can use a delay, but that would be complex, so let's make it a button for now.
    First, we'll pass the onSearchSubmit to the Search component:
    ``` JSX
    render() {
      const { searchTerm, result } = this.state;
      return (
        <div className="App">
          <Search
            value={searchTerm}
            onChange={this.onSearchChange}
            onSubmit={this.onSearchSubmit}
          />
          {result && (
            <Table
              list={result.hits}
              pattern={searchTerm}
              onDismiss={this.onDismiss}
            />
          )}
        </div>
      );
    }
    ```

    Then, add a button in the Search component with type 'submit' and onClick triggers onSubmit(),
    we can use the children property to add content to the button:
    ``` JSX
    const Search = ({ value, onChange, onSubmit, children }) => (
      <div className="Search">
        <form onSubmit={onSubmit}>
          <input type="text" value={value} onChange={onChange} />
          <button type="submit">{children}</button>
        </form>
      </div>
    );
    ```

    Now we can remove the filtering done on the table i.e. the client-side search, and remove the isSearched function.
    Now, if we try to search, the browser will reload, since this is the default event handler for submit, so we have to prevent that in onSearchSubmit:
    ``` JSX
    onSearchSubmit(event) {
      const { searchTerm } = this.state;
      this.fetchSearchTopStories(searchTerm);
      event.preventDefault();
    }
    ```

    Now, the search will work as intended, a server-side search.

### Paginated Fetch
When we did the fetch, the data structure returned has more than a list of hits,
the page property which is set to 0 can be used to fetch more paginated sublists as results, we only need to pass the next page with the same search term to the API.

Let's extend our API in the code to add a page parameter:
``` JSX
const DEFAULT_QUERY = "redux";
const PATH_BASE = "https://hn.algolia.com/api/v1";
const PATH_SEARCH = "/search";
const PARAM_SEARCH = "query=";

const PARAM_PAGE = 'page='; //see? we added it easily, that's why we made the url flexible ^_^
```

Now we can compose our url like this (example: searching in page 5):
    `${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}&${PARAM_PAGE}5`; (ES6)
    PATH_BASE + PATH_SEARCH + '?' + PARAM_SEARCH + searchTerm + '&' + PARAM_PAGE + '5'`; (ES5)

The fetchSearchTopStories method can take a second argument: the page, set the default to 0.
``` JSX
fetchSearchTopStories(searchTerm, page = 0) {
  fetch(`${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}&${PARAM_PAGE}${page}`)
    .then(response => response.json())
    .then(result => this.setSearchTopStories(result))
    .catch(error => error);
}
```

Now, we can add a button that loads next pages in our app,
that button will trigger fetchSearchTopStories but will give it a page argument,
that page argument should be the next page i.e. current page + 1:
``` JSX
render() {
    const { searchTerm, result } = this.state;
    const page = (result && result.page) || 0; //first, we get the page number or set it to 0.

    return (
      <div className="App">
        <Search
          value={searchTerm}
          onChange={this.onSearchChange}
          onSubmit={this.onSearchSubmit}
        />
        {result && (
          <Table
            list={result.hits}
            pattern={searchTerm}
            onDismiss={this.onDismiss}
          />
        )}
        <div className="interactions">
          <button //here's our new button
            onClick={() => this.fetchSearchTopStories(searchTerm, page + 1)} //and here are our arguments
          >
            ...More
          </button>
        </div>
      </div>
    );
  }
}
```

Finally, we can make the function concatenate the current page with the new fetched page so that we have all the results in front of us:
``` JSX
  setSearchTopStories(result) {
    const { hits, page } = result; //first we get the new hits and the new page number
    const oldHits = page !== 0 ? this.state.result.hits : []; //then we get the old hits if there is any, or an empty array if there isn't any i.e. we're fetching the first page
    const updatedHits = [...oldHits, ...hits]; //now we concatenate both into a big array

    this.setState({
      result: { hits: updatedHits, page } //then we set the hits to our big array and we update the page number to the latest page fetched
    });
  }
```

Finally, we can modify our request to specify the number of hits each request fetches, we just add another parameter to our url:
``` JSX
const DEFAULT_QUERY = "redux";
const PATH_BASE = "https://hn.algolia.com/api/v1";
const PATH_SEARCH = "/search";
const PARAM_SEARCH = "query=";
const PARAM_PAGE = "page=";

const PARAM_HPP  = "hitsPerPage="; //again, flexibility at its best B|
const DEFAULT_HPP = 5; //an example
```

Then update the fetchSearchTopStories method:
``` JSX
  fetchSearchTopStories(searchTerm, page = 0) {
    fetch(
      `${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}&${PARAM_PAGE}${page}&${PARAM_HPP}${DEFAULT_HPP}`
    )
      .then(response => response.json())
      .then(result => this.setSearchTopStories(result))
      .catch(error => error);
  }
```

Of course, we can add a hitsPerPage parameter to the function's argument and pass it, making it customizable.
We're awesome, aren't we? B|

### Client Cache
If we search for 'redux' then 'thor' then 'redux' again, there are three fetch requests, we can further improve the performance by CACHING results on client-side so that when we search for 'redux' for the second time we don't make a server request, we just get the stored results.

This requires us to store many 'results' in the internal state, not one 'result', so we'll make our 'result' a map with search terms as keys and the results (and page number, 5alek zaky b2a xD) fetched as values.

To do this:
- Step 1: rename 'result' to 'results' in the constructor and add another property to the local state called searchKey, this stores the last fetch result temporarily.
``` JSX, constructor
    this.state = {
      results: null,
      searchTerm: DEFAULT_QUERY,
      searchKey: null //we'll see what's that later
    };
```

- Step 2: modify componentDidMount and onSearchSubmit to set searchKey to searchTerm before the fetch is made, because searchTerm changes every time we type into the search field, but searchKey stores the SUBMITTED search term, it can be used to get the correct result from the map of results.
``` JSX
  onSearchSubmit(event) {
    const { searchTerm } = this.state;
    this.setState({ searchKey: searchTerm }); //here's the part we added
    this.fetchSearchTopStories(searchTerm);
    event.preventDefault();
  }

  componentDidMount() {
    const { searchTerm } = this.state;
    this.setState({ searchKey: searchTerm }); //here's the part we added
    this.fetchSearchTopStories(searchTerm);
  }
```

- Step 2: modify the function setSearchTopStories to store the result in the local state by key. 
``` JSX
  setSearchTopStories(result) {
    const { hits, page } = result;
    const { searchKey, results } = this.state;

    const oldHits =
      results && results[searchKey] ? results[searchKey].hits : [];
    const updatedHits = [...oldHits, ...hits];

    this.setState({
      results: {
        ...results,
        [searchKey]: { hits: updatedHits, page }
      }
    });
```

- Step 4: modify the render function:
``` JSX
render() {
    const { searchTerm, results, searchKey } = this.state;
    const page =
      (results && results[searchKey] && results[searchKey].page) || 0;
    const list =
      (results && results[searchKey] && results[searchKey].hits) || [];

    return (
      <div className="App">
        <Search
          value={searchTerm}
          onChange={this.onSearchChange}
          onSubmit={this.onSearchSubmit}
        />
          <Table 
            list={list}
            pattern={searchTerm}
            onDismiss={this.onDismiss}
          />
        <div className="interactions">
          <button
            onClick={() => this.fetchSearchTopStories(searchKey, page + 1)}
          >
            ...More
          </button>
        </div>
      </div>
    ); //notice we removed the condition on Table, since the default is an empty list
  }
}
```

- Step 5: add a check that if the search term is cached, do NOT make the request,
  we'll add a function that does that, needsToSearchTopStories(searchTerm), then we'll modify onSearchSubmit
``` JSX
needsToSearchTopStories(searchTerm) {
  return !this.state.results[searchTerm];
}

onSearchSubmit(event) {
    const { searchTerm } = this.state;
    this.setState({ searchKey: searchTerm });
    if(this.needsToSearchTopStories(searchTerm)) {
      this.fetchSearchTopStories(searchTerm);
    }
    event.preventDefault();
  }
```
Don't forget to bind the new function in the constructor.

- Step 6: modify the onDismiss
``` JSX
onDismiss(id) {
    const { searchKey, results } = this.state;
    const { hits, page } = results[searchKey];

    const isNotId = item => item.objectID !== id;
    const updatedHits = hits.filter(isNotId);
    this.setState({
      results: { 
        ...results,
         [searchKey]: {hits: updatedHits, page }
      }
    });
  }
```

Now we have an efficient search and caching technique in React ^_^

### Error Handling
We'll handle errors like an erroneous API request, etc.
We already know two building blocks for error handling in React: local state, and conditional rendering.

The concept is: error is part of the local state, if it happens we store it and render it, that's it ^_^
``` JSX, App constructor
this.state = {
      results: null,
      searchTerm: DEFAULT_QUERY,
      searchKey: '',
      error: null
    };
```

Now we'll modify the catch block in the fetch request to store the error in the local state:
``` JSX
  fetchSearchTopStories(searchTerm, page = 0) {
    const url = `${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}&${PARAM_PAGE}${page}&${PARAM_HPP}${DEFAULT_HPP}`;
    fetch(url)
      .then(response => response.json())
      .then(result => this.setSearchTopStories(result))
      .catch(error => this.setState({error}));
    console.log(url);
  }
```

Then, we modify the render function to display ONLY the error (conditional rendering):
``` JSX
render() {
    const { searchTerm, results, searchKey, error } = this.state;
    const page =
      (results && results[searchKey] && results[searchKey].page) || 0;
    const list =
      (results && results[searchKey] && results[searchKey].hits) || [];

    if(error) {
      return(<p>Something went wrong, ${error}</p>);
    }

    return (
      <div className="App">
        <Search
          value={searchTerm}
          onChange={this.onSearchChange}
          onSubmit={this.onSearchSubmit}
        />
        <Table list={list} pattern={searchTerm} onDismiss={this.onDismiss} />
        <div className="interactions">
          <button
            onClick={() => this.fetchSearchTopStories(searchKey, page + 1)}
          >
            ...More
          </button>
        </div>
      </div>
    );
  }
```
In render, this approach will only display the error or the whole app, so it might not be the best UX.
Let's change it a little:
``` JSX
render() {
    const { searchTerm, results, searchKey, error } = this.state;
    const page =
      (results && results[searchKey] && results[searchKey].page) || 0;
    const list =
      (results && results[searchKey] && results[searchKey].hits) || [];

    return (
      <div className="App">
        <Search
          value={searchTerm}
          onChange={this.onSearchChange}
          onSubmit={this.onSearchSubmit}
        />
        {error ? (
          <div className="interactions">
            <p>Something went wrong, ${error}</p>  //ONLY the table doesn't render if there's an error
          </div>
        ) : (
          <Table list={list} pattern={searchTerm} onDismiss={this.onDismiss} />
        )}
        <div className="interactions">
          <button
            onClick={() => this.fetchSearchTopStories(searchKey, page + 1)}
          >
            ...More
          </button>
        </div>
      </div>
    );
  }
```

That's it ^_^ to test it, we can change PATH_BASE to 'https://hn.foo.bar.com/api/v1'.

### Axios instead of Fetch
Axios is another API for fetching requests, it's better than Fetch API because not all browsers support Fetch API and browser-less development environments (headless browser environment) don't always support it either.
Axios is a stable library.

Note: fetch api CAN WORK with both browsers and headless browsers, but with polyfills and in tests, that won't be discussed here.

How to use axios:
- Installation:
  >> npm install axios

- Importing:
  ``` import axios from 'axios';

- Usage:
  It's very similar to Fetch, it returns a promise, you don't have to convert response to JSON, axios does that and returns a 'data' object.
  ``` JSX
  fetchSearchTopStories(searchTerm, page = 0) {
    const url = `${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}&${PARAM_PAGE}${page}&${PARAM_HPP}${DEFAULT_HPP}`;
    axios(url)
      .then(result => this.setSearchTopStories(result.data)) //here we adapt our code to 'data'
      .catch(error => this.setState({ error }));
    console.log(url);
  }
  ```

  axios() uses an HTTP GET request, we can also use axios.get(), other requests are axios.post(), etc.

If you made a request, then unmounted the component by navigating to another page or whatever, the fetch request may still be running, which means you may use setState on an unmounted component, this should be handled.
We can do that by aborting the request when the component unmounts, this is a best practice in React.
But doing that sin't implemented in the promise API, so we might use workarounds like this one:

Declare a class variable (not in local state) which holds the lifecycle state of the component. Initialize with false.
becomes true when component is mounted i.e. at componentDidMount
becomes false when component is unmounted i.e. at componentWillUnmount
use that to prevent steps when component is unmounted.
``` JSX
class App extends Component {
  _isMounted = false; //here;s our new variable
  ....
  componentDidMount() {
    this._isMounted = true;
    ....
  }

  componentWillUnmount() {
    this._isMounted = false;
    ....
  }

  ....

  fetchSearchTopStories(searchTerm, page = 0) {
    const url = `${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}&${PARAM_PAGE}${page}&${PARAM_HPP}${DEFAULT_HPP}`;
    axios(url)
      .then(result => this._isMounted && this.setSearchTopStories(result.data))
      .catch(error => this._isMounted && this.setState({ error }));
    console.log(url);
  }
}
```

End of chapter 2 ^_^

### Here's our app so far, you can skip this part if you're not confused or you're practicing along
``` JSX
import React, { Component } from "react";
import axios from "axios";
import "./App.css";

const DEFAULT_QUERY = "redux";
const PATH_BASE = "https://hn.algolia.com/api/v1";
const PATH_SEARCH = "/search";
const PARAM_SEARCH = "query=";
const PARAM_PAGE = "page=";
const PARAM_HPP = "hitsPerPage=";
const DEFAULT_HPP = 5;

// const url = `${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${DEFAULT_QUERY}`;

class App extends Component {
  _isMounted = false;

  constructor(props) {
    super(props);
    this.state = {
      results: null,
      searchTerm: DEFAULT_QUERY,
      searchKey: "",
      error: null
    };

    this.fetchSearchTopStories = this.fetchSearchTopStories.bind(this);
    this.onSearchSubmit = this.onSearchSubmit.bind(this);
    this.setSearchTopStories = this.setSearchTopStories.bind(this);
    this.onDismiss = this.onDismiss.bind(this);
    this.onSearchChange = this.onSearchChange.bind(this);
    this.needsToSearchTopStories = this.needsToSearchTopStories.bind(this);
  }

  // Class methods

  needsToSearchTopStories(searchTerm) {
    return !this.state.results[searchTerm];
  }

  fetchSearchTopStories(searchTerm, page = 0) {
    const url = `${PATH_BASE}${PATH_SEARCH}?${PARAM_SEARCH}${searchTerm}&${PARAM_PAGE}${page}&${PARAM_HPP}${DEFAULT_HPP}`;
    axios(url)
      .then(result => this._isMounted && this.setSearchTopStories(result.data))
      .catch(error => this._isMounted && this.setState({ error }));
    console.log(url);
  }

  setSearchTopStories(result) {
    const { hits, page } = result;
    const { searchKey, results } = this.state;

    const oldHits =
      results && results[searchKey] ? results[searchKey].hits : [];
    const updatedHits = [...oldHits, ...hits];

    this.setState({
      results: {
        ...results,
        [searchKey]: { hits: updatedHits, page }
      }
    });

    console.log(this.state.results);
  }

  onSearchSubmit(event) {
    const { searchTerm } = this.state;
    this.setState({ searchKey: searchTerm });
    if (this.needsToSearchTopStories(searchTerm)) {
      this.fetchSearchTopStories(searchTerm);
    }
    event.preventDefault();
  }

  onSearchChange(event) {
    this.setState({
      searchTerm: event.target.value
    });
  }

  onDismiss(id) {
    const { searchKey, results } = this.state;
    const { hits, page } = results[searchKey];

    const isNotId = item => item.objectID !== id;
    const updatedHits = hits.filter(isNotId);
    this.setState({
      results: {
        ...results,
        [searchKey]: { hits: updatedHits, page }
      }
    });
  }

  // Lifecycle methods
  componentDidMount() {
    this._isMounted = true;
    const { searchTerm } = this.state;
    this.setState({ searchKey: searchTerm });
    this.fetchSearchTopStories(searchTerm);
  }

  componentWillUnmount() {
    this._isMounted = false;
  }

  render() {
    const { searchTerm, results, searchKey, error } = this.state;
    const page =
      (results && results[searchKey] && results[searchKey].page) || 0;
    const list =
      (results && results[searchKey] && results[searchKey].hits) || [];

    return (
      <div className="App">
        <Search
          value={searchTerm}
          onChange={this.onSearchChange}
          onSubmit={this.onSearchSubmit}
        />
        {error ? (
          <div className="interactions">
            <p>Something went wrong, ${error}</p>
          </div>
        ) : (
          <Table list={list} pattern={searchTerm} onDismiss={this.onDismiss} />
        )}
        <div className="interactions">
          <button
            onClick={() => this.fetchSearchTopStories(searchKey, page + 1)}
          >
            ...More
          </button>
        </div>
      </div>
    );
  }
}

const Search = ({ value, onChange, onSubmit, children }) => (
  <div className="Search">
    <form onSubmit={onSubmit}>
      <input type="text" value={value} onChange={onChange} />
      <button type="submit">Search This</button>
    </form>
  </div>
);

const Table = ({ list, pattern, onDismiss }) => (
  <div className="Table">
    {list.map(item => (
      <div className='table-row' key={item.objectID}>
        <span>{item.title} - </span>
        <span>
          <button onClick={() => onDismiss(item.objectID)} type="button">
            Dismiss
          </button>
        </span>
      </div>
    ))}
  </div>
);

export default App;
```
## Code Organization & Testing
Now that we've proven ourselves to be just amazing in React, we'll become even more amazing and focus on how to keep our code scalable and maintainable.
We'll learn best practices of structuring folders and files to become even much more awesome.
And guess what? At the end we'll learn testing, Hot diggity dog we'll be Johnny-bravo-level of awesomeness.

### ES6 Modules
'import' is the equivalent of include in C/C++, 'import' in java and python, and 'using' in C#.
It lets us share code across many files.
That was already solved by us structuring our js scripts order in HTML, or other mundane approaches too.

The 'import/export' functionality was also implemented using JS hacks, but the problem was that everyone on the same project should follow ONE hack to standardize things.
ES6 came to the rescue and just introduced 'import/export'.

They allow us to split code into files to make it more reusable and readible.

So how do import/export work?
- We can share variables:
  ``` sandbox file1.js
  const negan = 'Negan';
  const daryl = 'Daryl';

  export { negan, daryl };

  ``` sandbox file1.js >>>> sandbox file2.js
  import { negan, daryl } from './file1.js';
  console.log(negan);
  
  ``` sandbox file1.js >>>> sandbox file3.js
  import * as theWalkingDead from './file1.js'; //we can import all variables in one object and give it an alias.
  console.log(theWalkingDead.daryl);
  
  ``` sandbox file1.js >>>> sandbox file4.js
  import {negan as N, daryl as D} from './file1.js';
  console.log(N);
  ```
  Note: I'll reuse the filenames of any sandbox, that doesn't mean they are linked, sandbox is a code playground.

- We can use the 'default' statement:
  - to export/import a single functionality.
  - to highlight the main functionality of th exported API of a module.
  ``` sandbox file1.js 
  //reflecting the previous note, this file1.js has NOTHING to do with the previous file1.js
  const saviors = {
    negan: 'negan',
    dwight: 'dwight'
  }

  export default saviors;
  
  ``` sandbox file1.js >>>> sandbox file2.js
  import thatThing from './file1.js'; //without curly braces, it will import the default.
  console.log(thatThing); //Output: { negan: 'negan', dwight: 'dwight' } 
  ```

### Code organization with ES6 modules
So, how can we split our application's code?
There are many approaches, for exapmle:
  src/ 
    index.js
    index.css
    App.js
    App.test.js
    App.css
    Button.js
    Button.test.js
    Button.css
    Table.js
    Table.test.js
    Table.css
    Search.js
    Search.test.js
    Search.css

That's not bad, but we can see a lot of name duplication already, so let's improve it:
src/
  index.js
  index.css
  App/
    index.js
    test.js
    index.css
  Button/
    index.js
    test.js
    index.css
  Table/
    index.js
    test.js
    index.css
  Search/
    index.js
    test.js
    index.css

That looks cleaner.
We can also extract the constants from the App component:
src/
  index.js
  index.css
  constants/
    index.js
  components/
    App/
      index.js
      test.js
      index.css
    Button/
      index.js
      test.js
      index.css
    Table/+
      index.js
      test.js
      index.css
    Search/
      index.js
      test.js
      index.css

  Note: From now on, we'll split our code into files, and in examples here we'll write the name of the file like this:
    ``` JSX App.js
    ...
    ```
  NOTE: WE WILL FOLLOW THIS STRUCTURE FROM NOW ON.
  

Where the constants/index.js file would look like this:
``` JSX src/constants/index.js
export const DEFAULT_QUERY = "redux";
export const PATH_BASE = "https://hn.algolia.com/api/v1";
export const PATH_SEARCH = "/search";
export const PARAM_SEARCH = "query=";
export const PARAM_PAGE = "page=";
export const PARAM_HPP = "hitsPerPage=";
export const DEFAULT_HPP = 5;
```

And the App.js file  will be the index.js file and will contains this:
``` JSX src/components/index.js
import {
  DEFAULT_QUERY,
  DEFAULT_HPP,
  PATH_BASE,
  PATH_SEARCH,
  PARAM_SEARCH,
  PARAM_PAGE,
  PARAM_HPP,
} from '../constants/index.js';
....
```

If the file you're importing is called 'index.js' for example App/index.js, you can omit the filename.
  import App from './components/App';

Why?
node.js introduced this convention, index.js is the entry point to a module, it describes the public API of the module.
So that we don't have to dig into other files of one module to get functionality, we just import them from one file.


### Snapshot tests with Jest
We won't dive deep into testing, but we'll check it out.
Also, contrary to the popular and dangerous belief, a developer SHOULD TEST, and SHOULD KNOW HOW TO TEST.
Just because there's a QA department doesn't mean you shouldn't test your code, and yes I mean TESTING, not just 'running'.
Yes, you don't have to go through all testing phases, but at least do some unit, regression, and integration testing.

Tip: read 'The Clean Coder', and read about Test-Driven-Development

Unit testing: testing a small block of code e.g. a function, a class, etc.
  Sometimes unit tests of some blocks succeed, but these blocks WHEN integrated they don't work, 
  so you should group them and test them together.
Integration testing: what we just said above.
  But also, testing the whole system is a must, it's like the biggest integration testing.
End-to-end testing: what we just said.

How many tests do I need?
- Many unit tests to cover ALL corner cases of each block, this is called Code Coverage.
- Many integration tests to cover the combinations of code blocks you expect, and all the branches you can reach,
  this is almost 100% Code Coverage.
- A few end-to-end tests to simulate critical scenarios and real-life scenarios.

We will try using a library called Enzyme, and another framework called Jest, we'll go with Jest first.

Jest is a JS testing framework, used in React for react component tests, and is shipped with create-react-app.

Let's open the file src/components/App/test.js (formerly src/App.test.js):
``` Jest src/components/App/test.js
import React from 'react';
import ReactDOM from 'react-dom';
import App from './index';

it('renders without crashing', () => {
  const div = document.createElement('div');
  ReactDOM.render(<App />, div);
  ReactDOM.unmountComponentAtNode(div);
});
```

The 'it' block describes ONE test case, comes with a description.
When it's tested, it either succeeds or fails.
To do this test (and all the test cases in the app), we can run
>> npm test
This will run any files with an extension like this '.test.js'

Jest enables us to write Snapshop Tests. These make a snapshot of our rendered component and run that against future snapshots.
So if a snapshot changes, the test will notify us and we can accept or reject this change.
So we only test the diffs of the rendered output.
Jest stores the snapshots in a folder, which can be shared across teams.

How to write a snapshot test with Jest?
- Step 1: >> npm install --save-dev react-test-renderer
- Step 2: go to src/components/App/index.test.js
  ``` Jest src/components/App/index.test.js
  //first, import the new functionality:
  import React from 'react';
  import ReactDOM from 'react-dom';
  import App from './index';

  //Step 1: import the new functionality
  import renderer from 'react-test-renderer';

  //Step 2: (I think it's optional) wrap the it block with a 'describe' block, it's just a simple block.
  describe('App', () => {
    it('renders without crashing', () => {
      const div = document.createElement('div');
      ReactDOM.render( < App /> , div);
      ReactDOM.unmountComponentAtNode(div);
      console.log('Moamen is testing App/index.js');
    });

    //Step 3: now we'll write our test inside the describe block
    test('has a valid snapshot', () => {
      const component = renderer.create( <App />);
      let tree = component.toJSON();
      expect(tree).toMatchSnapshot();
    });
  });
  ```

If we run our tests again they will succeed, and the console will say '1 snapshot written' or something like that.
The renderer.create() makes a snapshot of our App component i.e. it renders it then stores the resulting DOM in a snapshot.

So, if we change the output of the render function in App i.e. the DOM generated, the test should fail.

Let's add tests for Search and Table:
``` Jest src/components/Search/index.test.js
import React from "react";
import ReactDOM from "react-dom";
import Search from "./index";
import renderer from "react-test-renderer";

describe("Table", () => {
  it("renders without crashing", () => {
    const div = document.createElement("div");
    ReactDOM.render(<Search>Search</Search>, div);
    ReactDOM.unmountComponentAtNode(div);
    console.log("Moamen is testing App/index.js");
  });

  test("has a valid snapshot", () => {
    const component = renderer.create(<Search>Search</Search>);
    let tree = component.toJSON();
    expect(tree).toMatchSnapshot();
  });
});

``` Jest src/components/Search/index.test.js >>>> Jest src/components/Table/index.test.js
import React from "react";
import ReactDOM from "react-dom";
import Table from "./index";
import renderer from "react-test-renderer";

describe("Table", () => {
  const props = {
    list: [{ objectID: '1', title: "1" }, { objectID:'2', title: "2" }]
  };

  it("renders without crashing", () => {
    const div = document.createElement("div");
    ReactDOM.render(<Table {...props} />, div);
    ReactDOM.unmountComponentAtNode(div);
    console.log("Moamen is testing App/index.js");
  });

  test("has a valid snapshot", () => {
    const component = renderer.create(<Table {...props} />);
    let tree = component.toJSON();
    expect(tree).toMatchSnapshot();
  });
});

```

If you run the tests now, you should get all successful.
Snapshot tests' purpose is to check if the component changes its output, if it does then we accept the change or reject it and fix the component.

### Unit Tests with Enzyme
How to use this library?
- Step 1: >> npm install --save-dev enzyme react-addons-test-utils enzyme-adapter-react-16
- Step 2: include it in your test setup:
  ``` Enzyme anytestfile.test.js
  import Enzyme from 'enzyme';
  import Adapter from 'enzyme-adapter-react-16';

  ....

  Enzyme.configure({ adapter: new Adapter() });
  ```
  Now we can write our first unit test, we will write a unit test in the Table 'describe' block.
  We will use shallow() to render our component and assert that it has two items. (we pass two list items).
  ``` Enzyme src/components/Table/index.test.js
  import {...}
  import Enzyme, { shallow } from 'enzyme';
  import Adapter from 'enzyme-adapter-react-16';

  Enzyme.configure({ adapter: new Adapter() });

  describe("Table", () => {
    const props = {
      list: [{ objectID: '1', title: "1" }, { objectID:'2', title: "2" }]
    };
    
    ....

    it('shows two items in list', () => { //here's our unit test
      const element = shallow(
        <Table {...props} />
      );

      expect(element.find('.table-row').length).toBe(2);
    });

    ....

  });
  ```

shallow() renders a component without its children, so we can make tests dedicated to ONE component.
Enzyme can render in three ways:
- shallow().
- render(): renders component and all children.
- mount(): renders component and all children, and gives access to lifecycle methods.

How to choose your render method in an Enzyme test?
- Always begin with shallow.
- if componentDidMount or componentDidUpdate will be tested, use mount.
- if you're testing lifecycle and children, use mount.
- if only children, use render.

Now you can run the tests and do whatever you want.

### Component Interface with PropTypes
JS has no data types, there are TypeScript and Flow that help with that functionality, but editors can catch type errors before these programs.
React has a built-in type checker, we can use PropTypes to describe our component interface.
All props passed from a parent to a child get validated based on the Proptypes interface assigned to a child component.

 How to use PropTypes:
 - Step 1: >> npm install prop-types
 - Step 2: import it in your react file e.g. App/index.js:
    import PropTypes from 'prop-types';
- Step 3: let's assign a props interface to components:
  ``` JSX-PropTypes sandbox
  //let's say we have a Button component as an FSC (FUnctional Stateless Component)
  const Button = ({ onClick, className = '', children }) => 
    <button
      onClick={onClick}
      className={className}
      type="button">
      {children}
    </button>

  //now we'll use PropTypes to assign types:
  Button.propTypes = {
    onClick: PropTypes.func, //this means, a function is expected to be passed here.
    className: PropTypes.string, //this means, a string is expected to be passed here.
    children: PropTypes.node //same concept
  }
  ```

When you run, these types will get validated when the props are passed.
The basic and complex types are:
PropTypes.array
PropTypes.bool
PropTypes.func
PropTypes.number
PropTypes.object
PropTypes.string
PropTypes.node
PropTypes.element

There's more, check the React documentation.
If a property isn't passed a value it becomes undefined, if you want to ENFORCE giving a value to it you can do this:
``` JSX-PropTypes sandbox
Button.propTypes = {
  onClick: PropTypes.func.isRequired,
  className: PropTypes.string,
  children: PropTypes.node.isRequired
}

Button.defaultProps = { //this is a React feature, we can use it instead of ES6 default values to keep code clean
  className: ''
}
```
And you can dive deep into properties of properties.

End of chapter 3 ^_^
## Advanced React Components
Here we'll explore advanced react components, duh xD

### Ref a DOM element
Sometimes we need to interact with our DOM nodes in react, there's an attribute 'ref' that give us access to nodes in elements.
Usually this is opposite to the declarative pattern in React, but some cases require it:
- To use the DOM API.
- To invoke imperative DOM node animations.
- To integrate with a third-party library that needs the DOM node e.g. D3.js

We'll try the 'ref' attribute on the Search component:
(as an example, if you want to remove that later that's okay, 
  we don't really need it in our app and we'll revert things in our app after we finish):
- Step 1: refactor the Search component into an ES6 class component.
``` JSX src/components/Search/index.js
import React, { Component } from "react";

class Search extends Component {
  render() {
    const { value, onChange, onSubmit, children } = this.props;
    return (
      <div className="Search">
        <form onSubmit={onSubmit}>
          <input type="text" value={value} onChange={onChange} />
          <button type="submit">Search This {children}</button>
        </form>
      </div>
    );
  }
}

export default Search;
```

- Step 2: use the ref attribute, the "this" object helps us reference the DOM node with 'ref'.
``` JSX src/components/Search/index.js
class Search extends Component {
  render() {
    ...
          <input
            type="text"
            value={value}
            onChange={onChange}
            ref={node => {
              this.input = node;
            }}
          />
          ...
  }
}
```

- Step 3: now we can focus the input field when the component is mounted using 
  "this" + DOM API + the appropriate lifecycle method

``` JSX src/components/Search/index.js
class Search extends Component {
  componentDidMount() {
    if(this.input) {
      this.input.focus();
    }
  }

  render() {
    ...
          <input
            type="text"
            value={value}
            onChange={onChange}
            ref={node => {
              this.input = node;
            }}
          />
          ...
  }
}
```

Now the input field will be focused when the app renders.
That's how you can use ref.

Can you use ref with an FSC?
Yes, like this
``` JSX src/components/Search/index.js
const Search = ({ value, onChange, onSubmit, children }) => {
  let input;
  return (
     ...
        <input
          type="text"
          value={value}
          onChange={onChange}
          ref={node => (input = node)}
        />
        
      ...
  );
};
export default Search;
```

That isn't of much help, though, since we can't access lifecycle methods, we can't implement our focus thing.
But you might come across use cases where an FSC with a ref attribute is useful, so now you know how to use it.

Now I'll revert things in the app.

### Loading...
You might want to show a Loading indicator when you submit a search request:
- Step 1: (in a file DOMconstants.js in src/constants)
``` JSX src/constants/DOMconstants.js (Or you can put it in App/index.js directly without import and export)
import React from 'react';
const  Loading = () => <div>Loading...</div>;
export default Loading;
```

- Step 2: modify the App component:
``` JSX src/components/App/index.js
import {...}
import Loading from '../../constants/DOMconstants';

...
class App extends Component {
  constructor(props) {
    ....
    this.state = {
      ....,
      isLoading: false
    }
    ....
  }
  ....
}
```

- Step 3: when you make a request, set the isLoading to true, when the results are fetched, set it to false:
``` JSX src/components/App/index.js
class App extends Component {
  ....
  fetchSearchTopStories(searchTerm, page = 0) {
    this.setState({
      isLoading: true
    })
    ....
  }

  setSearchTopStories(result) {
    ....
    this.setState({
      results: {
        ...results,
        [searchKey]: {hits: updatedHits, page}
      },
      isLoading: false
    });
  }
  ....
}
```

- Step 4: conditional rendering of the Loading component in our App, in the render function:
``` JSX src/components/App/index.json

```

### Higher-order components
Remember higher-order functions? functions that take other functions as input and return functions as output?
Higher-order components (HOC) are the same concept, they take components as input and return components as output.

Why would we need such a thing?
- Prepare properties, manage state or representation of a component.
- For conditional rendering.
- And other use cases..

Let's make an HOC: (new file src/hoc/index.js) 
NOTE: this is my (Moamen's) file structure, not sure if it's a best practice.
``` JSX src/hoc/index.js
import React from 'react';

//it's a practice to prefix the name of a HOC with 'with'
function withFoo(Component) {
    return function(props) {
        return <Component {...props}></Component>;
    }
}
// you can convert all of that into arrow functions.
```

Here, this HOC takes a component as input and returns it just as it is.
Let's enhance it: a loading component shows until the component is rendered:
``` JSX src/hoc/index.js
...
import Loading from '../constants/DOMconstants/index.js';

function withLoading(Component) {
    return function(props) {
        return props.isLoading
          ? <Loading />
          : <Component {...props}></Component>
        ;
    };
}
```

The spread operator makes it efficient not to write all props manually, but maybe the input component doesn't care about isLoading,
so you can do this:
``` JSX src/hoc/index.js
...
import Loading from '../constants/DOMconstants/index.js';

function withLoading(Component) {
    return function({isLoading, ...rest}) {
        return props.isLoading
          ? <Loading />
          : <Component {...rest}></Component>
        ;
    };
}
```

That way, we take one property out of the object before rendering the output component.
Let's replace the Loading of the ...More button with the withLoading HOC.

First we'll wrap the button into our own component Button:
``` JSX src/components/myButton/index.js
import React from "react";

const myButton = ({ onClick, className = "", children }) => (
  <button onClick={onClick} className={className} type="button">
    {children}
  </button>
);

export default myButton;
```

Then we'll modify the render function in App/index.js:
``` JSX src/components/App/index.js
class App extends Component {
  ....
  render() {
    const { searchTerm, results, searchKey, error, isLoading } = this.state;
    ....

    return (
      <div className="App">
        ....
        <div className="interactions">
          <ButtonWithLoading
            isLoading={isLoading}
            onClick={() => this.fetchSearchTopStories(searchKey, page + 1)}
            >
              ...More
          </ButtonWithLoading>
        ....
      </div>
    );
  }
  ....
}
```

### Advanced Sorting and lodash
It would be convenient to enhance Table with sorting.
There are tons upon tons of sorting algorithms, but we can use the famous library 'Lodash'.

Step 1: >> npm install lodash
Step 2: import it:
  import { sortBy } from 'lodash';
Step 3:
  We have many columns in our table, we want to define sort functions where each function takes a list and returns it sorted by a specific property.
  Plus one default sort functions which returns the unsorted list, so let's make an object of functions:
  ``` JSX src/constants/index.js
  export const SORTS = {
    NONE: list => list,
    TITLE: list => sortBy(list, 'title'),
    AUTHOR: list => sortBy(list, 'author')
  };
  ```

  The sort functions returns a reversed list.
  App component keeps which sort functionality is currently used in its local state:
  ``` JSX src/components/App/index.js
  ....
  class App extends Component {
    constructor(props) {
      ....
      this.state = {
        ....
        sortKey: 'NONE'
      };
      ....
    }
    ....
  }
  ```

  So, whenever the sort key is changed, the table will be sorted with the appropriate sort function.
  Now we need to add a function:
  ``` JSX src/components/App/index.js
  ....
  class App extends Component {
    constructor(props) {
      ....
      this.onSort = this.onSort.bind(this);
    }
    ....
    onSort(sortKey) {
      this.setState({
        sortKey
      });
    }
    ....
  }
  ```

  Table is responsible for applying the sort, so we should pass the sortKey to Table and add the property.
  Also, we need to add a row of column headers so that when we click on one, the sortKey is set, otherwise it will remain 'NONE':
  ``` JSX src/components/Table/index.js  
  ....
  import { SORTS } from '../../constants';

  const Table = ({ list, sortKey, onSort, onDismiss }) => (
    <div className="Table">

      <div className="table-header"> //here's the header
        <span style={{width: '40%'}}>
          <Sort sortKey={'TITLE'} onSort={onSort}>Title</Sort>
          <Sort sortKey={'AUTHOR'} onSort={onSort}>Author</Sort>
        </span>
      </div>

      {SORTS[sortKey](list).map(item => (
        ....
      ))}
    </div>
  );
  ```

  This means, we need to make a Sort component, we'll just put in in Table/index.js:
  ``` JSX src/components/Table/index.js
  ....
  import { SORTS } from '../../constants';
  import myButton from "../myButton"

  const Sort = ({sortKey, onSort, children}) => {
    return <MyButton onClick={() => onSort(sortKey)}>{children}</MyButton>;
  };

  const Table = ({ list, sortKey, onSort, onDismiss }) => (
    <div className="Table">

      <div className="table-header"> //here's the header
        <span style={{width: '40%'}}>
          <Sort sortKey={'TITLE'} onSort={onSort}>Title</Sort>
          <Sort sortKey={'AUTHOR'} onSort={onSort}>Author</Sort>
        </span>
      </div>

      {SORTS[sortKey](list).map(item => (
        ....
      ))}
    </div>
  );
  ```

  Then include that in Table.

  Finally, modify the render function:
  ``` JSX src/components/App/index.js
  ....
  class App extends Component {
    ....
    render() {
      const {
        ....
        sortKey
      } = this.state;
      ....

      return (
        <div className="App">
          ....
            <Table
              list={list}
              sortKey={sortKey}
              pattern={searchTerm}
              onDismiss={this.onDismiss}
            />
          ....
        </div>
      );
    }
  }
  ```

  You should find the sort working ^_^

Note: Okay, I'll skip the reverse sort for now, I'll get back to it later maybe, but for now I'll skip it.

End of Chapter 4 ^_^

## State Management
We already learned the basics of state management, here we'll dig deeper and learn best practices and how to apply them.
Also, we will consider using a third-party library to manage the state.

### Lifting State
So far, only the App component is a stateful component (stateful: has a state, i.e. an ES6 class component, stateful is opposite of stateless btw).
We pass a lot of props in our Table component, so why does the App component know about them?
For example, the sort functionality, we can just move it to the Table component since App doesn't use it at all.

When we decide to move part of a state from a component to another, this is called 'Lifting State'.
In order to do this of course, we need to make Table an ES6 component, 
then move sortKey, onSort, and any sorting-related thing to Table:
``` JSX src/components/Table/index.js
import React, { Component } from "react";
....

class Table extends Component {
  constructor(props) {
    super(props);
    this.state = {
      sortKey: 'NONE'
    };

    this.onSort = this.onSort.bind(this);
  }

  onSort(sortKey) {
    this.setState({
      sortKey
    });
  }

  render() {
    const {list, onDismiss} = this.props;
    const {sortKey} = this.state;
    const sortedList = SORTS[sortKey](list);

    return (
      ...
            <Sort sortKey={"TITLE"} onSort={this.onSort}>
              Title
            </Sort>
            <Sort sortKey={"AUTHOR"} onSort={this.onSort}>
              Author
            </Sort>
          ...
        {sortedList.map(item => (
          ...
        ))}
      </div>
    );
  }
}
```

In App component we remove everything we moved to Table, including the props passed to Table.
We made App and Table both more lightweight, and more reusable since now Table can handle more use cases.

Read more about lifting state, it's a best practice.

### setState() revisited
We've used setState a ton, we'll dig deeper into it.
- setState can take a callback function that returns an object instead of an object, like this:
``` JSX sandbox
this.setState((prevState, props) => {
  ...
});
```

Why would we do that?
- A crucial use case: when we update the state depending on the PREVIOUS state or props.
For example, counting:
``` JSX sandbox
const { fooCount } = this.state;
const { barCount } = this.props;
this.setState({
  count: fooCount + barCount
});
```

setState is asynchronous, so what if fooCount and barCount change asynchronously?
This could cause some errors and race conditions because some functions may execute depending on the NEW VALUE of count
while setState hasn't finished adding them because it's async, creating a race condition problem.

When we pass a callback function, even if setState is async, the callback function executes synchronously.
So the better approach would be:
``` JSX sandbox
this.setState((prevState, props) => {
  const { fooCount } = this.state;
  const { barCount } = this.props;
  return { count: fooCount + barCount };
});
```

In our app, where can that be found and fixed?
i.e. is there any setState function that depends on previous state/props?
Yes, in App component, in setSearchTopStories().\

We can move the whole block of code in the function except the first line, 
inside a callback function inside setState:
``` JSX src/components/App/index.js
setSearchTopStories(result) {
    const { hits, page } = result;

    this.setState((prevState) => { //we don't depend on the props, so only prevState
      const { searchKey, results } = prevState; //this.state was changed to prevState
      const oldHits =
        results && results[searchKey] ? results[searchKey].hits : [];
      const updatedHits = [...oldHits, ...hits];

      return {
        results: {
          ...results,
          [searchKey]: { hits: updatedHits, page }
        },
        isLoading: false
      };
    });
  }
```

This will fix the issue, we can even extract the function and pass its name for readibility:
``` JSX src/components/App/index.js
setSearchTopStories(result) {
    const { hits, page } = result;

    const updateSearchTopStoriesState = prevState => {
      const { searchKey, results } = prevState;
      const oldHits =
        results && results[searchKey] ? results[searchKey].hits : [];
      const updatedHits = [...oldHits, ...hits];

      return {
        results: {
          ...results,
          [searchKey]: { hits: updatedHits, page }
        },
        isLoading: false
      };
    };

    this.setState(updateSearchTopStoriesState);
  }
```

You can extract the function outside App itself, for this you'll to pass hits & page since now 
the function can't access them directly, so we'll need the function updateSearchTopStoriesState
to return the callback function we'll call from setState i.e. updateSearchTopStoriesState is a higher-order function
that takes two arguments: hits, page, then it returns another function that takes prevState as argument.

Like this:
``` JSX src/components/App/index.js
....

//the function is outside class App, and check its signature out:
const updateSearchTopStoriesState = (hits, page) => (prevState) => {
  const { searchKey, results } = prevState;
  const oldHits =
    results && results[searchKey] ? results[searchKey].hits : [];
  const updatedHits = [...oldHits, ...hits];

  return {
    results: {
      ...results,
      [searchKey]: { hits: updatedHits, page }
    },
    isLoading: false
  };
};


class App extends Component {
  ....
  setSearchTopStories(result) {
    const { hits, page } = result;
    this.setState(updateSearchTopStoriesState(hits, page));
  }
  ....
}
```

As a bonus, the function is now testable outside App, we can export it and write unit tests for it.

### Taming the state
The management of components' local states is a crucial and hard topic, as apps get more complex it becomes harder,
but also more important.
Other SPA frameworks struggle with this too.

Because of that, there are standalone solutions that take care of state management, like:
- The famous Redux.
- MobX.
They're not covered in this book, but you can learn them, start with Redux.

## Final steps to production
Here we'll learn how to deploy our app for production.

### Eject
create-react-app comes with a feature to keep it extendable, when a technology isn't extendable it's called a vendor lock-in.
create-react-app has a solution for this: 'eject'.

BEWARE: this command is a one-way operation, once you do this you cannot go back, so tread lightly.

>> npm run eject

This copies all configuration and dependencies to the package.json file and a new config/folder.
This converts the whole project to a custom setup that may include other tools like Webpack, Babel, etc.

### Deployment
Finally, to go live, we can use a service called Heroku, it's a service where we can host our app.
it integrates with React seamlessly with zero configuration.

To use Heroku:
- Step 1: install Homebrew, check its documentation since it's a series of steps and commands.
- Step 2: install Heroku CLI: (brew is a Homebrew command)
  >> brew update
  >> brew install heroku-toolbelt
- Step 3: this is lame, go and create a free Heroku account xD
- Step 4:
  >> git init
  >> heroku create -b https://github.com/mars/create-react-app-buildpack.git
  >> git add .
  >> git commit -m "my app is on on Heroku"
  >> git push heroku master
  >> heroku open

### Last words
Here we learned react, from here you can extend your app, try another React project.
Before you go into another book, make another hands-on React project and try to apply everything, 
from scratch to deployment.
What you can learn from here:
  - State management: dig deep into this, learn Redux and MobX.
  - Connecting to a DB & authentication.
  - Webpack and Babel tooling.
  - React Component Syntax and best practices.
  - UI components.
  - Code organization.
  - Testing.
  - Routing: learn how to use react-router.
  - Type-checking.
  - React Native.

This is Moamen, signing off...
