# How to become a Software Engineer
Hi :raising_hand: this is a small guide on how to use these courses (or any other courses that match the ones here) to become a Software Engineer, if you don't know anything about Software Engineering.

I'll talk here about:
- What is software engineering from the point of view of a web developer in the industry.
- What are the knowledge areas that a software engineer should know.
- A series of steps for you to follow in order to cover the knowledge areas mentioned above.

## What exactly is Software Engineering
Have you ever played the game *Stronghold Crusaders*? <br/>
It's a great game, you are a king of a kingdom, and there are other kings with other kingdoms that want to conquer your lands, and you want to conquer theirs.

How do you win?
- Defeat the enemies.
- To defeat the enemies, you need an army.
- To raise an army, you need:
    + People to train and join the army.
    + Weapons for the army.
- You also need to make weapons.
- To make weapons, you need to get iron.
- To get iron, you need people to work in iron mines to get the iron.

Unlike any other strategy game, this game doesn't let you just command people to do stuff, you need to get these people to work by making them willing to work, so you have to:
- Provide food for them.
- Lower the taxes.
- Build gardens and beautiful places.

The problem is, to provide food, you need people to work as farmers, who also demand food. And if you fail to provide food or lower taxes, people will *refuse* to work for you, despite still consuming the little food that you have!

So, you need to manage your economy **very carefully** and **very quickly** in order to be able to raise an army *before* the enemy does. So yes, there is a time element too.

This game is hard, but would it be easier if instead of people, *machines* did all the work? Robots mining for iron, making weapons, providing food, and even robots fighting instead of people.

Robots won't need as much food or beautiful gardens, if these robots were powered by fuel for example, they will either work or malfunction due to low fuel or something, so instead of providing a lot of stuff, you only need to provide fuel.

But, people can be taught to forge weapons from iron, we can tell them basic instructions on what to do, so they perform the main process, how can we teach robots to do so?

By doing the same: tell them basic instructions on what to do, so they perform the main process, but how?
- We take our big process e.g. forging weapons from iron, and divide it into basic instructions like:
    1. Take iron.
    2. Heat iron.
    3. Hammer iron on flat anvil.
    4. While shape of iron is not flat, repeat step 3.
    5. Put flat iron in cold water.
    6. Make handle.
    7. Attach handle to iron.
    8. You made a sword!
- To tell robots that, we need to *speak their language.* 

But since we are the ones who made robots, we can make languages for them.
These languages are designed to tell them basic *instructions*, and a set of instructions that are performed together to achieve a goal are grouped and called a *Program* or *Code*, the instructions above are a *program to forge a sword*.

The process of telling robots to follow some programs is called *Programming* or *Coding*, and the languages we use are called *Programming Languages.*

So, the people who can use these *Programming Languages* to make the robots do stuff help the society (or the kingdom in the game) lower its costs, therefore helping the economy and the people by making food cheaper.

**This is how Programming helps community.** <br/>
Programming in real-life is telling computers to follow instructions to achieve some goals to help the society and the economy.

But, as time passed and a lot of programs were written, people discovered that writing programs is like writing books, it's an art form, a mix of art and science, and it should be done correctly.

So, creative programming artists began designing ways of writing programs, ways of making the computer work less and achieve more, ways to make many people write one program efficiently, and so on.

The art increased so much that we needed to distinguish between this new art and the plain old computer when talking about things, so words were developed to describe this new domain of programs: *Software*.

Then, genius people decided to search through all this *Software*, take the best out of it, and make these best art pieces a standard to follow by other programmers.

Then, business entrepreneurs began using *Software* a lot and thought of new ways to accelerate and fine-tune the process of writing *Software*.

Software programs grew in size and became gigantic, they achieved a lot of goals and made a lot of lives easier and better. Software programmers increased in numbers and each crafted their own art and science.

Software became not only *How to write good code*, it also includes:
- How to design a big program.
- How to make a team write the program.
- How to write good code in the program.
- How to maintain the program.

Other problems appeared and software artists began designing art to solve these problems, so much that these new art styles became fields in their own rights, like *Debugging*, *Testing*, *Automation*, *Software Architecture*, *Software Management*, and so on.

Then, creative programmers began using software to make new art, some created games, some created programs on a computer, some created programs that communicate across computers and the internet, some even created programs on mobile phones.

And thus, this gigantic software world that includes all of these art and science breakthrough, is collectively called ***Software Engineering.***

This is what Software Engineering is, and as you can see, I love it :heart:

## What should a Software Engineer know
Now don't get overwhelmed :smile: you don't need to know all of this, there are levels:

**Level 1 Software Engineer:** you need to know:
- How a computer works, because you know, that's the base of all this xD
- Programming first of all, how to talk with a computer.
- How to write *good* programs, how to transition from a *beginner* to a *beginner artist.*

So, the knowledge subjects you should explore are:
- *Computer Organization:* How a computer works.
- *Basics of Programming in a programming language.*
- *Algorithms and Data Structures:* How to write *good* code on the level of small code segments.
- *Object-Oriented Programming:* A way of writing programs such that they are easy to change and modify and closer to the real-world.
- *Programming paradigms:* These are ways to write big programs, one of them is *Object-Oriented Programming*.
- *Software Engineering:* The art of designing programs so that they are productive and easy to change.
- *Computer Networking:* How computer communicate with each other.

Now, you're a beginner software engineer, you're not ready for work yet, but you are ready to specialize in a field.

Some fields are:
- Desktop Application Development.
- Web Application Development.
- Video Game Development.
- Mobile Application Development.
- Embedded Systems Development.

There are a multitude of fields now, Machine Learning, AI, Bioinformatics, Business informatics, and a lot more.

Since I'm a web developer, I'll draw the roadmap for Web Development from here on, but from Level 1 you

**Level 2 Software Engineer: The Web Developer:** Welcome to the dark side my friend, now let's get into what you need to learn:
- In-depth Computer Networking.
- Databases.
- Software Architectural patterns.

Then, we'll go in how to actually develop web applications:
- Frontend Development.
- Backend Development.

Then, to be an web *artist* not only a developer, learn these skills:
- Software Debugging.
- Software Testing.

More theory for artists:
- Distributed Systems.
- Compiler Theory.
