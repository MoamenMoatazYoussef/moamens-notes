Sitecore Foundation:
====================
Tips:
-----
- Anything between //// and //// is code.
- Anything between *** and *** are titles of DEMOS shows in the modules, they're not noted here in details.
- This note doesn't have all details but I've written down the main concepts of everything and any details I could.
----------------------------------------------------------------------------------------------------------------------------------------------------------
Module 1:
---------
- Sitecore experience platform (Sitecore XP):
    - xManagement:
        It's the web content management part of Sitecore, allows us to:
            - Create, manage, publish content to websites.
            - It supports:
                - Data definition: the data schema, or "template" of sitecore, i.e. "what does the content consist of in sections? e.g. address, creator name, etc."
                    - This is developer-defined.
                - Content.
                - Presentation layer: created by VS and Sitecore Rocks using MVC or WebForms.
    - xConnect:
        - Connects xDB to other components, it collects and searches data.
        - decouples xDB from sitecore, and makes xDB able to connect to othre things e.g. mobile apps, etc.
    - xDB:
        - It stores "experience data".
        - It's the main database of sitecore.
        - It has integrated marketing and analytics capabilities.
        - It aggregates data for reporting.
        - 
- Sitecore combines xManagement with marketing functionality provided by the other two.

Architecture of Sitecore:
    
    - Horizontal scaling: many servers for one role.
    - Vertical scaling: many servers for different roles.
    
    - Content management server: Has access to all three DBs.
    - Content delivery server: Has access to web and core.
        - Both are conntected to three DBs:
            - Core: DB that contains config information about sitecore UI and security users, roles, etc. + .NET membership tables.
            - Web: Only the published content. (Read-only, we can't edit here).
            - Master: Every version of every item in every language including work in progress, this is where content is edited.
        Which are hosted on a SQL server in production.
    
Publishing: transferring changes from Master to Web, and removing rejected changes.

Popular Sitecore products:
    Sitecore Commerce: powered by sitecore and Microsoft Dynamics, can create multichannel commerce apps.
    Email Experience Manager: makes email campaigns for specific segments.
    Komfo Connector: create custom audiences using sitecore XDB data, which can be used for advertising on social networks.
        - quick access to Komfo platform and gives analytic overview of the social channel.
    Sitecore Mobile SDK for Xamarin: a framework to develop mobile apps to deliver and manage content managed by sitecore.
    Print Experience Manager: enables sitecore customers manage print production from sitecore.
    Federated Experience Manager: 

Sitecore XP 9.0 software requirements:
    - Windows server 2012 R2, windows server 2016 on windows 8.1 or later.
    - .NET framework 4.6.2.
    - IIS version 8 or later.
    - SQL server 2016 SP1 or later for xDB, 2014 SP2 or later for xManagement (Master, core, web).
    - Visual Studio 2015 or later.
    - Solr. (for xDB indexes).
** check HW requirements.

----------------------------------------------------------------------------------------------------------------------------------------------------------
Module 2: Creating the site's structure
---------
Objective: Define templates to use on a site, make values and items.

Main concept of items, fields, and templates:
---------------------------------------------
Content in sitecore is stored in Items, each item has some Fields that hold the data.
Each item needs a definition (A description of fields it should have), this is called Data Definition.
Data Definition is done by Templates, they define the fields that the item will have, and will be used to store data.
Item type: two items are the same type if they are based on the same Template.

Fields contain the actual content.
Fields are grouped in Sections.
Templates can have icons assigned to them, and items based on the same template will show in the tree with the icon defined in that template, so use icons.

Sitecore have a lot of templates and field types defined.
You can make your own, but that's seldom necessary.

Examples of fields in Sitecore:
- Text fields: single-line, multi-line, or Rich text.
- Media fields.
- Link fields:
    - Link to a single item: in the shape of Droplink, Grouped Droplink, or Droptree.
    - Link to multiple items: Multilist, Checklist, Treelist, TreelistEx. (These are just ways to present many links, if you don't get it now that's ok).
    - General Link Fields.
And Others...

Some fields require extra configuration beyond name and type, for example:
Field Source: defining choices of a list field or whatever. (This is used to configure the source of data that the field get from)
- Images: field source = path to image.

So:
Step 1: define the type of content to be created.
Step 2: define the fields and field types that describe that content.

Template Inheritance: (Recommended approach)
---------------------
- Create base template (Interface templates), and configure parent templates it should inherit from.
- All templates inherit from the Standard Template, which has System Fields.
- Templates to be used as parent templates only should have an underscore at the start of their name.
- Field names should be unique, field sections can be similar, Sitecore will MERGE field sections with the same name.
- Of course, avoid circular template inheritance.
- Field settings e.g. Field Source, cannot be overridden after inheriting templates.
- Templates are defined in the Sitecore content tree, there's a Template Editor app.
- You can create templates on Visual Studio using Sitecore Rocks plugin.
- 

Recommended practices:
----------------------
- Use short user-friendly names.
- Set icons.
- Make a folder structure and organize your templates.
- Make good use of inheritance.
- DO NOT repeat a field name. (If no other way, use the Title field type).
- Limit the use of Rich Text editors, they allow the end user to make changes to the website!

*** How to create templates and configure inheritance using Sitecore Rocks ***

Items:
------
They store website content.
They're stored in the tree at "/sitecore/content".
They have unique ID, they also have path: concatenation of names of its ancestors.
It's possible to create two items with the same name in the same location i.e. same path. this is a BAD PRACTICE AND SHOULD BE AVOIDED!
Items need to be locked before modifying to prevent others to modify data in them i.e. make them read-only.

To create an item:
- Choose a location in the tree.
- Choose a template the item will be based on.
- Give it a name.

- Or use "Insert From Template" option: this is NOT available for non-admins.
- So, as an admin, you need to provide non-admins with a list of templates to create items from.

*** Creating content and items using Sitecore Rocks ***

Standard values:
----------------
Items used to define default values and settings for items.
They're normal items named "__Standard Values".
So, if a field is empty and it has a standard value as its parent, the standard value will replace the "emptiness".
We cab use standard values to define initial values for when the item is created.
e.g.:
$date: sets the value of a field to the current date.
$now: same but date and time.
$name: sets the name of the item created.

Also, items inherited ALSO have standard values defined in parent templates or base templates.
Sitecore will follow the inheritance chain until it finds an inherited field with an initial value to use it if the main field is null.
If none found, the field value will remain null.

*** How to create standard values ***

Versioning:
-----------
- Fields can have different versions of the same data, for example in different languages.
- You can maintain a list of all changes of data in a field.

Media:
------
- Store media on the DB not the file system, it makes it easier to manage and publish data.
- Media items are based on templates too.
- Follow the Recommended practices for creating and maintaining media library.

- Follow the Information Architecture in the tree as you make content to make it easier for users to use, modify, etc.
- The number of versions and number of items under one item may affect performance.
----------------------------------------------------------------------------------------------------------------------------------------------------------
Module 3: Creating the site's Presentation
---------
After creating the structure, we want to transform this into the output that will be seen by the users, this is the role 
of the presentation layer.

Presentation layer task: transform sitecore stuff -> HTML or something like it.

The presentation layer can be made by WebForms and MVC.

When a request comes to Sitecore, it tries to match it to an item, if that succeeds, Sitecore uses the presentation
layer to make a response.

Layouts:
--------
Layouts are the equivalent of templates in the presentation layer.
Components are like items.

They are just .CSHTML files (C Sharp HTML, html files used for ASP.NET apps),
To use them in Sitecore, we need to register them with Sitecore by creating layout definition items.
These items contain path of the physical .CSHTML file within the site's web root.

Presentation details:
---------------------
A list of items storing information required by Sitecore to build a page response.
These are available for any item, stored in Standard Fields of any item.
When a request arrives to Sitecore, it tries to match it to an item, if successful, it uses the presentation details item to create the response.
You'll set these details, but the best practice is to set them NOT on items, but on STANDARD VALUES that the items inherit from.

For different devices:
----------------------
- Responsive approach: You can use media queries in css for responsive design.
- Adaptive approach: different output for each device, you do this by using Sitecore's "Devices" and the Presentation Details.

*** Creating a Layout and setting Presentation Details ***

Inline editing:
---------------
This is editing fields in the Experience Editor i.e. as they appear on the page.
Not all fields are available for inline editing because their renderings are different.

Rendering:
----------
Rendering fields can be done easily by:
//// JS?
@html.sitecore().field("Here you write the name of the field to render", anItemObject);
//// ENDCODE
We can add the second parameter to specify from where do we get the content. 
There are other parameters like DisableWebEdit, EnclosingTag, Format, @class.

Image manipulation:
-------------------
You can manipulate image sizing and stuff.
//// JS
@Html.Sitecore().Field("eventImage", new {width: 100px, @class="img-responsive"});
//// ENDCODE

*** Rendering Content ***

Componentizing your design:
---------------------------
Sitecore development and testing features depend on components so it's better to componentize the design.
To do this in MVC, we use:
    - View Rendering: (as far as I understand) they are files that modify html and produce other html, they're like molds,
        they are Standard Razor files i.e. CSHTML files, they're like XSLT, they're text files that are easy to create
        and edit, they can contain inline C# but not recommended, they're good for simple scenarios.
    - Controller Renderings: are the same idea, but they follow MVC pattern, they're mapped to some action of the controller 
        and invoke it, they're good for complex stuff.

To create a rendering:
Step 1: Create relevant files: view rendering, view, controller, etc.
Step 2: Create a definition item that points to relevant files.
    - For a view rendering, the definition item just needs path to the CSHTML file of the rendering.
    - For a controller rendering, the item needs Name, and Action that it invokes.

Controller should take data from business and translate it into the presentation structure, it should contain NO business logic.

Areas:
------
They are containers to compartmentalize models, views, and controllers.


----------------------------------------------------------------------------------------------------------------------------------------------------------
Module 4: Increasing Component Reusability
---------
Objective: 
    - Make things more reusable.
    - Use parameters to limit user access.

Content can be rendered by using:
    - Field Helper in Razor.
    //// Sitecore API
    var database = Sitecore.Context.Database;
    var item     = database.getItem(new Sitecore.Data.ID('item id'));
    var output   = FieldRenderer.Render(fieldItem, 'fieldName', 'params');
    //// ENDCODE

Setting a datasource on a component:
    A contextItem is mapped to a URL.
    a data source is a property associated with a component.
    You can retrieve it in code.

    Setting a datasource on an item makes it reusable since:
        - you can change datasource.
        - you can use it the datasource in optimization and testing scenarios.

    //// Sitecore API
    var contextItem    = RenderingContext.Current.ContextItem;
    var dataSourceItem = RenderingContext.Current.Rendering.Item;
    //// ENDCODE

You can choose where the new defined item in the tree:
    - Set the datasource location on the component definition item.
    - The "select associated item" box will open and be available.
    - Authors now can choose the content they want the component to use.

You can set datasource template field to restrict authors to specific items type and create items of THAT type.
When the datasource template field is used alone, authors can select "only the items specified in the template"
    from the entire content tree.

*** assign data source to a component ***

Parameters for a component:
    - Styling.
    - Configuration.
    - Output.

    These parameters are set per instance.
    They are stored as key/value pairs e.g.:
    CssClass = blue&;Button Text = Subscribe...
    You can add custom properties.
    To change the background color, you set 'Rendering parameter'.
    
//// Sitecore API
<h4 class="@Model.Rendering.Parameters["CssClass"]">This text is in blue</h4>
//// ENDCODE

Dynamic Placeholders:
    These allow us to inject code to be used in HTML.
    //// Sitecore API
    @Html.Sitecore().DynamicPlaceholder("column", ...otherArgs);
    //// ENDCODE

*** Working With Component Parameters ***

How to help authors customize:
------------------------------
- Don't give them access to additional parameters.
- Make rendering parameter templates, these allow you to define custom fields to set specific parameters, 
    like checkboxes, lists, etc.
- There's a standard rendering parameter template that you can extend and make your own custom templates.

*** Compiling a rendering parameter template: change background color using it ***

*** Explaining Compatible Renderings Behavior ***

----------------------------------------------------------------------------------------------------------------------------------------------------------
Module 5: Applying Navigation Practices Within the Site
---------
Objectives:
    - How Sitecore manages and renders links.
    - Use the Sitecore API to nagivate the tree.

Requests are mapped to items in the content tree using URL.
Creating links:
//// Sitecore API
Item i  = Sitecore.Context.Item;
var url = Sitecore.Links.LinkManager.GetItemUrl(i); //here we pass the item and get the url, reverse of what we described above.
//// ENDCODE 

Single URL per page is recommended.
Otherwise, do this:
//// Sitecore API
<link rel="canonical" href="your link here"/>
//// ENDCODE

Wildcard item: 
--------------
The asterisk * in the content tree will match to ANY request.
But you need to handle the request to generate the URL.

*** Adding a canonical link to the header ***

Navigating the tree:
--------------------
//// Sitecore API
var parentItem = context.Parent;
var children   = context.GetChildren();
foreach(var child in children) {
    //code to apply on children
}
//// ENDCODE

You can use LINQ in .NET framework to work with navigating the tree.

*** Navigating the Tree with API ***

----------------------------------------------------------------------------------------------------------------------------------------------------------
Module 6: Configuring and Extending Sitecore
---------
Objectives:
    - How the include folder configures Sitecore.
    - Install a package into Sitecore.
    - Define the file structure of a Sitecore instance.
    - Configure and Extend Sitecore.

Layers:
-------
Sitecore has a web.config file which is a configuration file, but not the only one.
Configuration of Sitecore = web.config + all files in App_Config
Sitecore groups the config files in layers i.e. folders in the App_Config folder.
Then the file layers.config dictates the order of processing of these folders.

When Sitecore starts up it loads:
    - web.config
    - ConnectionStrings.config
    - layers.config

Layers loaded in sequence:
    - Sitecore layer: basic config of Sitecore.
    - Modules layer: any extra config required by modules.
    - Custom layer: here we'll add our custom configs.
    - Environment layer: any changes environment-specific e.g. DEV, QA, Production servers.

A layer loads like this:
    - files in the layer folder in alphabetical order.
    - then subfolders are accessed in alphabetical order.
    - files inside subfolders are loaded in alphabetical order.

We can add config to layers.config by changing the order, or disabling some layers (mode="off").
This is useful if we're debugging and want to check each layer or turn off the Custom layer.

Files added to layers are "Patch config files" or "Include files".
We may want some namespaces, they are XML files and they should be declared in our config files.

To view configuration that is currently used, go to this path:
    /Sitecore/Admin/Showconfig.aspx
Or go to Sitecore Rocks and open that file.

Remember:
    - Horizontal scaling: 
    - Vertical scaling: many servers achieve one task.

In vertical scaling, even if all servers achieve one task, they can be configured differently, then we define Roles for each servers.
There are mainly 5 Roles:
    - Content Management: authors can create and publish content.
    - Content Delivery: makes web content available to website contacts.
    - Processing: Extract info from captured analytics data and transforms it into a suitable form for reporting.
    - Reporting: gets reporting data and reporting apps use that data.
    - Standalone(default): All roles together in one server. (This is good for dev servers).

*** Adding Include Config Files ***


Extending Sitecore:
-------------------
To extend Sitecore we use three types of files:
- Packages: are created by developers, they're used to move config files, code files, etc. across Sitecore, they are .zip files.
- Modules: are used to EXTEND Sitecore, they add functionality to it, they're found on the marketplace.
- Update Packages: these are release notes along with update files that have instructions on how to update Sitecore.

To create packages:
-------------------
- Use the Sitecore Package Designer.
- Use Sitecore Rocks.

To install packages:
--------------------
- Use Sitecore Rocks.
- Use the Control Panel of Sitecore.

You can remove packages but not all of them can be removed manually, because some of them overwrite pre-existing stuff.

*** Building and Installing a Package ***

Site configuration:
-------------------
Each site is modified in a different Node.
Each site has a unique name

Settings in a site include:
- Site name.
- Root path + start item = home item
- Default language.
- Database.
- Cache settings.

The default site config is found at App_Config/Sitecore.config.
To customize a site, DO NOT modify that file, create an include file 
    and put it in the Custom Layer to override the Sitecore.config defaults.

*** Configuring Sitecore for Hosting Multiple Sites ***

----------------------------------------------------------------------------------------------------------------------------------------------------------
Module 7: Complex Field Types
---------
Objectives:
    - Create a new components for events from complex field types.
    - How to deal with complex field types.

*** Working with Complex Field ***

NOTE: Watch this module, there's no notes that I could write about it, it's almost a big demo and everything is visual.
NOTE: This module is important, I just couldn't formulate notes about it.

----------------------------------------------------------------------------------------------------------------------------------------------------------
Module 8: Implementing Search-Driven Components
---------
Objectives:
    - Learn search features of Sitecore.
    - How to use 'buckets' to store large data.
    - How to use Content Search API in your code.

Searching:
----------
Authors can search both in content editor and experience editor.
When you click on a node in the tree, the search is conducted ONLY on that node and its children,
so if you want to search globally, select a top-level node.

Like any search engine, you can apply search filters, there are levels of restriction of the filters too:
- Must have: results must have ALL filters applied. (think of it as an AND gate where all criteria must be met)
- Should have: results must have ONE or more filters applied. (think of it as an OR gate).

Facet:
------
Facet is a filter that is applied to the results AFTER searching has finished.

Filters decide which results are shown.
Facets decide which INFO of each result is shown.

e.g. if we apply a Facet that says 'show me the template of the result', then the results will show, 
but ONLY THE TEMPLATE will show in each result. You can then choose to show results that all have the same template.

Bulk operations:
----------------
Sitecore UI by default operates on a single item at a time.
Search UI allows bulk operations over all search results.

*** Searching for Items in the Sitecore Client ***

Provider model:
---------------
Sitecore can use different search providers, Sitecore's search architecture depends on a Provider Model 
i.e. your code doesn't need to interact directly with a search engine.
Sitecore ships with implementations for two providers:
- Azure search. (Default)
- Solr.

You can add other providers, some search vendors make implementations for Sitecore.
You can switch providers halfway through development WITHOUT changing your code.

Searching in Sitecore does NOT crawl your website(pages), it crawls the data(items).
i.e. searching may get links that do NOT have presentation details and may not be accessible via URL, 
    so you NEED to provide these if you're going to render them.

Index configuration:
--------------------
It's done in the .config include files, you can specify:
- WHAT gets indexed, and
- HOW they should be indexed.

You can do this through code.
Indexing stuff that doesn't need to be indexed is wasting memory and performance, this is important.

The index:
----------
When a piece of content (an item) is indexed, it's called a 'document', 'documents' store info inside fields,
you can configure how item fields are mapped to document fields.
NOTE: you are usually specifying the EXCEPTIONS i.e. what DOESN'T get indexed.

Ways of indexing:
-----------------
Analyzer: it looks at the content to be indexed i.e. field values, parses it into tokens e.g. words. (<< THIS IS Language dependant >>)
The analyzer does this:
- Tokenizing: we can turn on/off tokenization for certain fields.
- Vectorizing: keeps pointers to where each token occures in the content, so the search engine can provide context around the terms.
- Storing: storage type dictates if the index will be a complete copy of the content being indexed.
    The index contains tokens provided by the analyzer.
    By default, index only contains certain tokens and not the whole content, and we use these tokens to find the index, 
    then the index to find the content.
    e.g. you open a cook book on the Contents page and find the word 'onion soup',
        but nothing else than the word and an page number (i.e. an index).
        then you go to the page number(i.e. index) and you fine the whole recipe and stuff about onion soup.

        What is onion soup anyways?

Computed fields:
----------------
Functions in your code that you define that takes:
- INPUT: raw value of the content to be indexed.
- OUTPUT: content that IS indexed.

These functions transform the input into something to be indexed, then indexes it.

Custom Indexes:
---------------
You can make custom indexes, extend existing indexes, and override existing indexes.

*** Rebuilding Indexes from the Control Panel ***

There are three default indexes, one for each of the DBs in Sitecore:
- sitecore_core_index.
- sitecore_web_index.
- sitecore_master_index.

Buckets:
--------
In big systems, the number of child items shouldn't grow out of control, because authors would have a hard time navigating the content tree.
When an author requests an item, Sitecore automatically requests its children too, so keep the number of children of each item small.

Alternatives for the content tree:
----------------------------------
1. Dividing content into Folders, there are Sitecore modules in the marketplace for this.
2. Buckets:
    A bucket ensures that a folder structure is created to reduce number of children per item.
    It hids this structure and content from the author's view, and it brings search interface to the forefront so that authors can use it to get their content.

When to create a bucket:
    during development, so that we plan in advance for any problems that may arise due to NOT using buckets.
    We can 'unbucket' items too.

When to consider using buckets at all:
    When an item is expected to have a lot of children.
    When we don't have to stick to a strict hierarchical tree structure.
    When we have LOTS of content.
    When structure isn't necessary in part of the tree.

To get the bucket functionality:
    - Make an item a bucket.
    - Configure which items get auto hidden and classified under that bucket i.e. making these items 'bucketable'.
        Best practice: set this on standard values, so that any items created from them are auto bucketable.

Buckets are stored in folder structures named by the time of creation of each item.
We can 'lock child relationship': maintain the hierarchical relationship between this item and its children when this item is stored in a bucket.

*** Introducing item buckets ***

Using search API in Sitecore:
-----------------------------
//// JS
var index = Sitecore.ContentSearch.ContentSearchManager.GetIndex("sitecore_master_index");
using(var context = index.CreateSearchContext()) {
    var results = //this is LINQ
        context.GetQueryable<Sitecore.ContentSearch.SearchTypes.SearchResultItem>()
        .Where(i => i.TemplateName == "Sample Item");
}
//// ENDCODE
Note: DO NOT HARDCODE INDEXES.
    Create a search context, you can get an object called Iqueryable<T> using the function GetQueryable(), then specify the type of item you're searching, then use LINQ to for mthe search expression (LINQ is a query language, similar to SQL in concept but not in syntax. It's part of .NET framework but has ports in JS and other languages).

You can make 'predicate builders', which are parts of code that CREATE dynamic LINQ queries based on the type of item you're searching for, in case you don't really know what it is.

DONE!
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------