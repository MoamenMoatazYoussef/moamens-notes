# Aspect-Oriented Programming
## Table of Contents
- [Aspect-Oriented Programming](#aspect-oriented-programming)
  * [Table of Contents](#table-of-contents)
  * [Tips](#tips)
  * [Let's get the show on the road](#let-s-get-the-show-on-the-road)
  * [Practical Stuff](#practical-stuff)
  * [AOP Programming Overview](#aop-programming-overview)
    + [Advices](#advices)
    + [The worst part of any framework - Setting Up Spring AOP](#the-worst-part-of-any-framework---setting-up-spring-aop)
    + [Now, to write some CODE!](#now--to-write-some-code-)
  * [AOP Pointcut Expressions](#aop-pointcut-expressions)
    + [Pointcut Expressions: basic Method Matching](#pointcut-expressions--basic-method-matching)
    + [Pointcut Expressions: Parameter Matching](#pointcut-expressions--parameter-matching)
    + [Pointcut Expressions: Package Matching](#pointcut-expressions--package-matching)
  * [Pointcut Declarations](#pointcut-declarations)
    + [Combining Pointcuts](#combining-pointcuts)
  * [AOP Ordering Aspects](#aop-ordering-aspects)
  * [AOP JoinPoints](#aop-joinpoints)
  * [More Advice Types](#more-advice-types)
    + [@AfterReturning Advice Type](#-afterreturning-advice-type)
    + [@AfterThrowing Advice Type](#-afterthrowing-advice-type)
    + [@After Advice Type](#-after-advice-type)
    + [@Around Advice Type](#-around-advice-type)
      - [Output problems](#output-problems)
      - [Handling Exceptions with @Around advice](#handling-exceptions-with--around-advice)
- [And now, we are DONE](#and-now--we-are-done)

<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>

## Tips
- sysout means System.out.print, I'm lazy.
- AOP: Aspect-oriented programming.
- Check out Spring and Hibernate notes before this one.

## Let's get the show on the road
Remember the DAO we made in the last project?
We wrote code like this:
``` Java
public void add(Account a, String id) {
    Session session = sessionFactory.getCurrentSession();
    session.save(a);
}
```

While we're working on that code and being awesome, our boss comes to our desk and says:
Boss: "Heyy, we need to add some Logging to our DAO methods."
We: "Easy peazy lemon squeezy, we'll do that in an instant".
Boss: "Possibly more places, but we need to start ASAP and before you work on your TBS Reports."

So, we'll add the logging to the code:
``` Java
public void add(Account a, String id) {
    
    // add logging
    
    Session session = sessionFactory.getCurrentSession();
    session.save(a);
}
```

But then the boss comes over and says:
Boss: "Heyy dude, make sure the user is authorized before running the DAO methods, also ASAP."
We: "Okayyy, alright we'll do that"
``` Java
public void add(Account a, String id) {
    
    // logging code

    // security check code
    
    Session session = sessionFactory.getCurrentSession();
    session.save(a);
}
```
But then, the boss comes over and says: "Heyy, let's add that to all of our layers."
We: "Oh hell, I knew that was coming.."
So, you copy the code from DAO and paste it into other layers, and BOOM, done.
But, you don't feel confident about your code, you know.

Then the boss says: "Wow that was great work, add that to every layer in the entire system".

Then you resign xD <br/>

**So, what are the problems here?** <br/>
1. Code tangling: in the business logic method, we now have other code(logging, security) that has nothing to do with business logic.
2. Code scattering: if you're going to change or update the logic of that other code, you'll have to update EVERY FILE.

Well, that, is a problem. <br/>

**So, what solutions do I have other than what I did?**
1. Inheritance?
    - WE can add security and logging code in a parent class, then everyone inherits from it.
    - But, that requires all classes to extend it, still updating every file.
    - Also, what if they already extend from other classes (Jave doesn't support multiple inheritance).
2. Deligation?
    - We'll delegate logging and security calls to manager classes.
    - Same problem, we'll need to touch all of the files and classes.

But, in the darkest of times, comes a hero, the hero we all need:
**Aspect-Oriented Programming** <br/>

- It's a programming technique that's based on the concept of an "Aspect".
- An Aspect that encapsulates Cross-cutting logic (cross-cutting logic means basic infrastructure code that all apps need).
- An aspect is a class that can be applied to different parts of your projects based on your configuration.
- It's liker layers put on top of your classes.

What does AOP help us achieve?
- Proxy design pattern: main app calls the target object's methods.
    - The main app doesn't know anything about AOP, it just makes a method call.
    - THAT phone call is not directly going to the target object.
    - It's going through some "hackers", but good hackers.
    - These are the AOP code.
    - This means, we don't have to worry about AOP at all while writing our business logic code.


## Practical Stuff
**AOP Terminology** <br/>
- Aspect: A class that contains this cross-cutting logic.
- Advice: A method inside an aspect that has some cross-cutting logic and executes at specific points of the program, an aspect is a class that contains methods, these methods are "Advices".
- Join point: points where we run the AOP code.
- Pointcut: expressions for where advices should be applied.
- Advising an object: it means assigning AOP code (methods inside aspects i.e. advices) on target objects (other classes and methods) so that advices run at some time relative to target objects (Before them, after them, etc.), when that happens, the target object is called "Advised object".
- Weaving: Connecting Aspects to target objects to create an "advised" object, an object that's layered with AOP code .
    - Compile-time weaving.
    - Load-time weaving.
    - Run-time weaving.

**Advice types** <br/>
An advice is a method inside an Aspect(A class used for AOP).
Since we can make these methods -these advices- run at a time relative to other classes and methods, we can classify these methods according to when do they run:
- Before advice: an advice method that runs before the target object (method or class) runs.
- After finally advice: an advice method that runs in the finally block.
- After returning: an advice method that runs after successful execution of a method.
- After throwing: an advice method that runs after failed execution of a method (exception thrown).
- Around: an advice method that runs before and after execution of a method.

**AOP Frameworks for Java** <br/>
- AspectJ: 
    - The OG(original gangsta) of AOP.
    - Provides complete AOP support.
    - Supports join points at class level, method level, constructor level, and field level.
    - Supports the three types of code weaving.
    - Works with any POJO (Plain Old Java Object).
    
- Spring AOP: 
    - Spring uses AOP in the background.
    - Supports user-defined AOP stuff.
    - Uses Proxy pattern.
    - Supports method-level join points only.
    - Uses run-time weaving only, which causes a small performance cost.

**Comparison between the two** <br/>
- AspectJ is much more complex than Spring AOP.
- But AspectJ is very fast and more powerful.
- AspectJ supports full AOP.
- Spring supports most of AOP's features.

**So what do I choose?** <br/>
- Start with Spring AOP.
- If things require really complex AOP programming, move to AspectJ.

**Resources** <br/>
- Spring AOP: www.spring.io, the documentation of Spring.
- AspectJ: "AspectJ in Action" Book.
- AOP as a concept and its use cases: "Aspect-Oriented Development with Use Cases" Book.

**What will we do here?** <br/>
- We'll cover Spring AOP.
- Create aspects.
- Develop Advices with all their types.
- Create pointcut expressions.
- Apply this to our Spring + Hibernate CRM project.

## AOP Programming Overview
### Advices
**@BeforeAdvice** <br/>
- The Before advices is code that runs before a certain method runs.
- So, our main app will call a method.
- We want our own custom code execute BEFORE it.

**When and why do we use this? Use cases** <br/>
- Logging, security, transactions (for example the @Transactional spring annotation we used before).
- Audit logging
- API management, for example Who called a method, How many times was it called, what is the peak time of calling this method, etc.

**How do we do that?** <br/>
We'll have a main app, this main app will use a DAO to call a method.
We'll inject some AOP before the method executes.

**Development Steps:**
1. Create target object, the DAO.
2. Create a Spring Java Config class.
3. Create main app.
4. Create an aspect using an @Before annotation.

**Best Practices with AOP** <br/>
That code will execute EVERY TIME this method is called, so:
- Keep the code small and fast.
- Do not perform slow operations.
- Get in and get out as quickly as possible.

### The worst part of any framework - Setting Up Spring AOP 
Eclipse:
- Remember spring-demo-one or spring-demo-annotations? Copy one of them, paste it, call it "spring-demo-aop".
- Delete all src files and all packages.
- We need the AspectJ jar files since Spring AOP uses it, download it:
    + don't choose the beta version, choose the latest stable version
    + in the next screen download the JAR file from the Files tab:
    + www.luv2code.com/download-aspectjweaver
- Copy it into your lib directory.
- Add all JARS in the lib directory (spring JARs and the AspectJ JAR) to the build path of the project.

Done baby B) <br/>

### Now, to write some CODE!
**Step 1: Create the target object** <br/>
- Create a new package: com.luv2code.aopdemo
- Create another package: com.luv2code.aopdemo.dao
- Create the target object, the DAO class, annotate it with @Component, add one method, inside it sysout anything.
``` java
@Component
public class AccountDAO {
	public void addAccount() {
		System.out.println("I'm in the main method.");
	}
}
```

**Step 2: Create the Spring Config class** <br/>
- Create a Spring Confige java class.
- Annotate it with @Configuration and @ComponentScan, passing in the package.
- Annotate it with @EnableAspectJAutoProxy, the new component that enables AOP to execute in a proxy design pattern manner.
``` Java
@Configuration
@EnableAspectJAutoProxy
@ComponentScan("com.luv2code.aopdemo")
public class DemoConfig {

}
```

**Step 3: Create the main app** <br/>
- We did that before xD
``` Java
public class MainDemoApp {

	public static void main(String[] args) {
		AnnotationConfigApplicationContext context = 
				new AnnotationConfigApplicationContext(DemoConfig.class);
		
		AccountDAO theAccountDAO = context.getBean("accountDAO", AccountDAO.class);
		
		theAccountDAO.addAccount();
		
		context.close();
	}

}
```

**Step 4: Create the AOP code** <br/>
- The AOP code is called an "Aspect",
- Create a new package: com.luv2code.aopdemo.aspect
- In it, create a new class: MyDemoLoggingAspect.
- Annotate it with @Aspect and @Component (So that Spring can pick it up during component-scanning).
- Inside the class, write a method, inside it write a sysout or something.
- Annotate that method with @Before("execution(public void addAccount())"):
    + Before: means that this method will run Before a specific event. That event is what we pass as argument.
    + The word "Execution" means: execute the method Before any execution of what we'll pass inside.
    + Then, we pass the name of our method.
    + So, this annotation means: Execute this function Before every time the function addAccount executes.
    + That function, is called an "Advice".
``` java
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class MyDemoLoggingAspect {

	@Before("execution(public void addAccount())")
	public void MyAdvice() {
		System.out.println("I'm in the Advice now.");
	}
}
```

Now, run the main app, observe the output.
Now this is spying on the code :smile: <br/>
Try calling the method many times in the main app, see the output and watch the advice method run every time the main method is called, but before it.

## AOP Pointcut Expressions
Remember when we wrote that @Before annotation, and inside it we wrote some stuff that defined WHEN the advice method is applied?
This stuff is an expression called a Pointcut Expression, it's like a condition that, when met, the advice method is applied.

Pointcut Expressions are a language specific to AspectJ, and Spring AOP uses it.

### Pointcut Expressions: basic Method Matching
**How do we write Pointcut Expressions** <br/>
Pointcut Expressions have a specific syntax that consists of Patterns.
All of the patterns must be matched for the aspect to run. 
For example we have the Execution expression:
```
execution(modifiers-pattern? return-type-pattern declaring-type-pattern? method-name-pattern(param-pattern) throws-pattern?)
```
All patterns that have "?" are optional.
What do those patterns mean?
- modifiers-pattern: match on a specific modifier (if we have two methods of the same name and everything but one is public the other is private, whatever is specified in the modifiers pattern will ONLY have the aspect run before it(or after or whatever, according to the type of aspect))
- return-type-pattern: what's the return type to match?
- declaring-type-pattern: what's the class name of the type to match?
- method-name-pattern: what's the name of the method?
- param-pattern: what are the parameters that should be there for the AOP to execute?
- throws-pattern: does the method throw a given exception?

Patterns can get wildcards * i.e. that pattern matches with everything.

**Some Examples** <br/>
Example:
``` Java
@Before("execution(public void com.luv2code.aopdemo.dao.AccountDAO.addAccount())")
```
- Modifiers pattern: public
- Return type pattern: void
- Declaring type: com.luv2code.aopdemo.dao.AccountDAO.
- Name: addAccount.
- parameters and throws patterns: nothing.

This means:
Execute this aspect before every execution of:
- the public function 
- called "addAccount"
- that returns void
- that's declared inside com.luv2code.aopdemo.dao.AccountDAO
- that takes NO parameters
- and throws NO expressions.

Example:
``` Java
@Before("execution(public void addAccount())")
```
- Modifiers pattern: public
- Return type pattern: void
- Declaring type: nothing (it's an optional pattern)
- Name: addAccount.
- parameters and throws patterns: nothing.

This means:
Execute this aspect before every execution of:
- the public function 
- called "addAccount"
- that returns void
- that's declared inside ANY CLASS (see the difference here?)
- that takes NO parameters
- and throws NO expressions.

Example:
``` Java
@Before("execution(public void add*())")
```
- Modifiers pattern: public
- Return type pattern: void
- Declaring type: nothing (it's an optional pattern)
- Name: any name that starts with "add" (interesting..)
- parameters and throws patterns: nothing.

This means:
Execute this aspect before every execution of:
- the public function
- whose name starts with "add" (add, addAccount, addThisNumber, addBlaBla, etc.)
- that returns void
- that's declared inside ANY CLASS
- that takes NO parameters
- and throws NO expressions.

Example:
``` Java
@Before("execution(* * add*())")
```
- Modifiers pattern: any modifier
- Return type pattern: any return type
- Declaring type: nothing (it's an optional pattern)
- Name any name that starts with "add"
- parameters and throws patterns: nothing.

This means:
Execute this aspect before every execution of:
- any function
- whose name starts with "add"
- with any return type
- that's declared inside ANY CLASS
- that takes NO parameters
- and throws NO expressions.

**Let's apply that in code** <br/>
In the previous code, this is our pointcut expression:
``` Java
@Before("execution(public void addAccount())")
```
**In the code, try these** <br/>
+ **Case 1:** In the expression, change the name of the method from addAccount to updateAccout (a method we don't have).
+ **Case 2:** Create a new class MembershipDAO, and inside it define a method: public void addAccount(), then call it and the old addAccount method in the main app.
+ **Case 3:** add a declaration type in the pointcut expression i.e. change it to this:
``` Java
@Before("execution(public void com.luv2code.aopdemo.dao.AccountDAO.addAccount())")
``` 
**Hint:** select the class name AccountDAO, choose Copy Qualified Name, paste it before the method name and add a dot after it.
+ **Case 4:** use the wildcard, change the name of the method to "add*" (don't forget to remove the FQN of the class name), and change the name of the addAccountin MembershipDAO to "addSillyMember" for example.
+ **Case 5:** change the membershipDAO method's modifier to default, then in the expression, change the modifier to the wildcard * i.e. do this:
``` Java
@Before("execution(* void add*())")
```
+ **Case 6:** change the return type from void to the wildcard "*" i.e.
``` Java
@Before("execution(* * add*())")
```

**Run the code each time and observe the output** <br/>
+ **Case 1 output:** the AOP code won't execute ever, because the method updateAccount doesn't exist in our code.
+ **Case 2 output:** the AOP code will execute before both method calls, because we don't define a declaration type for our method.
+ **Case 3 output:** the AOP code will execute only before the first method call (the old addAccount), because this is the one declared in the declaration type we specified, the other is in MembershipDAO.
+ **Case 4 output:** the AOP code will execute before both method calls, because it will match any method whose name has "add" in its start, regardless of what follows.
+ **Case 5 output:** the AOP code will execute before both method calls, because it will match any method whose name has "add" in its start, regardless of what follows or what's the modifier of the method.
**Case 6 output:** the AOP code will execute before both method calls, because it will match any method whose name has "add" in its start, regardless of what follows, the modifier, or the return type.

### Pointcut Expressions: Parameter Matching
We can specify specific parameters to match.
**Case 1:** we can use some wildcards like:
- (): match method with no arguments.
- (*): match method with *one* or more arguments.
- (..): match method with *zero* or more arguments. (i.e. anything)

**Case 2:** we can specify arguments by passing the Fully Qualified Name of the parameter type, for example:
``` Java
@Before("execution(* * addAccount(com.luv2code.aopdemo.Account))")
```
This means, match with:
- a method of any return type,
- and any modifier,
- whose name is addAccount,
- which takes one parameter of type Account

Notice that we wrote the FQN of the parameter type.

**Case 3:** we can match with more than one parameters:
``` Java
@Before("execution(* * addAccount(com.luv2code.aopdemo.Account, ..))")
```
This means, match with:
- a method of any return type,
- and any modifier,
- whose name is addAccount,
- which takes one parameter of type Account, 
- and any number of arguments following it (the wildcard).

Of course, we don't have to only use wildcards, we can specify two parameters, three, four, etc.

### Pointcut Expressions: Package Matching

**Our Case** we can match with any method in a given package:
``` Java
@Before("execution(* * com.luv2code.aopdemo.dao.*(..))")
```
This means, match with:
- a method of any return type,
- and any modifier,
- which is in the package com.luv2code.aopdemo.dao
- of any name,
- which takes any number of arguments following it.

## Pointcut Declarations
Pointcut expressions are awesome, but..do we really have to rewrite an expression if we want to reuse it with many methods?

Well, we could copy and paste it, but hey we're developers, we know the dangers of copy & paste xD

So, the solution is to create the expression once, then apply it to multiple devices.

This is called Pointcut Declaration, and it's done using a very nice annotation @Pointcut, to do this, we do some steps. <br/>

**Development Steps:**
1. Create the annotation and inside it write your pointcut expression.
2. Write an empty private void method under it, no args, no body.
``` Java
@Pointcut("execution(* * com.luv2code.aopdemo.dao.*(..))")
private void ourPointcutExpression() {}
```
That method under it, this isn't really a "business method", it's just a method defined under the annotation so that we can use it to Reference the expression.

How can we use this?
``` Java
@Aspect
@Component
public class MyDemoLoggingAspect {
    @Pointcut("execution(* * com.luv2code.aopdemo.dao.*(..))")
    private void ourPointcutExpression() {}

    @Before("ourPointcutExpression()")
	public void MyAdvice() {
		System.out.println("I'm in the Advice now.");
	}

    @Before("ourPointcutExpression()")
    public void anotherAdvice() {
        // stuff
    }
}
```
See, we can reuse expressions and we don't have to modify lots of things every time we reuse the expression :smile: <br/>

Also, we can SHARE and COMBINE pointcut expressions, we'll see that later.

### Combining Pointcuts
What if we want to apply multiple pointcuts on a single advice?
What if we want to execute and advice ONLY if certain pointcuts are met?
- For example, running an AOP if a method meets TWO conditions or more.

Well. we can COMBINE pointcut expressions :o
It works like an if statement, we use Logical operators(AND: &&, OR: ||, NOT: !) to combine pointcuts.

For example:
``` Java
@Before("expression1() && expression2()")
@Before("expression1() || expression2()")
@Before("expression1() && !expression2()")
```

So, we can create very generic atomic pointcuts, then reuse them to construct more complicated pointcuts that we apply to methods according to what we want.

**In Code** <br/>
Let's say we want two pointcuts in a class, and we want the AOP code to run before any method call from this class EXCEPT getters and setters.

In the previous code, we already have a pointcut, leave it and then modify the code:
- Add two fields: name and age.
- Generate getters and setters for them, put some sysouts so you can identify them in the output.

Now, in the AOP class:
- Add a new pointcut that matches a method:
    - of any return type,
    - any modifier,
    - any parameters,
    - whose name starts with "get"
    - and in the package com.luv2code.aopdemo.dao.
- Add another pointcut that matches a method:
    - of any return type,
    - any modifier,
    - any parameters,
    - whose name starts with "set"
    - and in the package com.luv2code.aopdemo.dao.
- Combine those three pointcuts to achieve the condition: advices execute before any method EXCEPT getters or setters.
``` Java
@Aspect
@Component
public class MyDemoLoggingAspect {
    @Pointcut("execution(* * com.luv2code.aopdemo.dao.*(..))")
    private void ourPointcutExpression() {}

    @Pointcut("execution(* * com.luv2code.aopdemo.dao.*.get*(..))")
    private void getter() {}

    @Pointcut("execution(* * com.luv2code.aopdemo.dao.*.set*(..))")
    private void setter() {}


    // here we are combining them:
    @Before("ourPointcutExpression() && !getter() && !setter()")
	public void MyAdvice() {
		System.out.println("I'm in the Advice now.");
	}
}
```
In the main app:
- Call getters and setters.
- Call normal methods.
- Run the code and see when does the advices run.
- Pat yourself on the back :smile:

## AOP Ordering Aspects
How do we control the order of advices applied if they all match the same condition?

Well, the order of advices is, by default, undefined. Spring wil call them in any order.

**How do we control the order, then?** <br/>
**Development Steps:**
1. Refactor the code, place the advices in separate aspects.
2. Control the order of Aspects using @Order annotation, it acts like Priority.

**In Code** <br/>
- Create two aspect classes, one called FirstAspect, one called SecondAspect (or anything), annotate them with @Aspect and @Component.
- In each one, define an advice method.
- In each one, annotate the advices with @Before and give them the same pointcut (declare the pointcut and reuse it).
- Annotate each aspect with @Order, and pass in numbers 1 and 2 for FirstAspect and SecondAspect, respectively. (Lower numbers = higher precedence)
FirstAspect:
``` Java
@Aspect
@Component
@Order(1)
public class FirstAspect {

	@Before("execution(public void addAccount())")
	public void MyAdvice() {
		System.out.println("I'm in the Advice of FirstAspect.");
	}
}
```

SecondAspect:
``` Java
@Aspect
@Component
@Order(2)
public class SecondAspect {

	@Before("execution(public void addAccount())")
	public void MyAdvice() {
		System.out.println("I'm in the Advice of SecondAspect.");
	}
}
```
- [Optional] Then, in the target class, create a method that matches the pointcut defined in both aspects.
- Call that method in the main app and run it, see in the output the order of advices.

***Note:*** The range of numbers that can be passed to @Order are Integer.MIN_VALUE to Integer.MAX_VALUE.
This means that negative numbers are allowed.
Also, we don't have to be consecutive, we could pass numbers 1 and 17, they'll order. 

***Note:*** What if two aspects have the same order, or two advices in the same ordered aspect? <br/>
This makes the order of these advices undefined.
They will still be in order relative to OTHER aspects of DIFFERENT order, but the order of the two relative to themselves is undefined.
i.e. if we have aspects of order 4, 6, 6, 8.
The two aspects ordered 6 will run after the aspect ordered 4 and before the one ordered 8,  but which one of them will execute first is undefined.

## AOP JoinPoints
When we're in an aspect, how can we access the advised method's parameters?

Advised method: method on which an advice is applied on. <br/>

**Development Steps:**
1. Access the advised method's signature.
    - This is done by adding an argument to the advice of type JoinPoint.
    - This gives us access to info about the advice, like using .getSignature() for example.
2. Access the advised method's arguments.
    - We can use the JoinPoint parameter to get the method's arguments as an array of Object, we do that using .getArgs().
    - So we can read the values passed to the arguments.

**In Code** <br/>
- Go to any aspect.
- Add a JoinPoint argument.
- Use it to get the signature.
- Use it to get the arguments, loop through them.
- Print them, and detect if one of them is of type "Account", then cast that account to something different (here we'll just cast it to Account).
``` Java
@Aspect
@Component
@Order(1)
public class FirstAspect {

	@Before("execution(public void addAccount(..))")
	public void MyAdvice(JoinPoint jp) {
		System.out.println("I'm in the Advice of FirstAspect.");
		
		// getting the signature of the function being called
		MethodSignature sig = (MethodSignature) jp.getSignature();
		System.out.println("Method: " + sig);
		

        // getting the args
		Object[] args = jp.getArgs();
		
        // looping through the args
		for(Object tempArg: args) {
			System.out.println(tempArg);
			
            // checking if tempArg is an Account
			if(tempArg instanceof Account) {
				Account theAccount = (Account) tempArg;
			}
		}
	}
}
```
Now run the code, and see the awesomeness :smile: <br/>

## More Advice Types
### @AfterReturning Advice Type
This advice runs after the method has completed successfully.

Here's the sequence:
- The main app calls a method that is advised using an @AfterReturning advice.
- The method executes to the end without exceptions, then it returns.
- At this point, the advice executes.

Use cases i.e. Why would we use this?
- Logging, security, Audit logging, the normal stuff.
- Post-processing data: format it, enrich it, etc. (A really cool feature, but use it wisely).

So, we can post-process the return type using an @AfterReturning aspect:
- To do that, we'll need to access the return value inside the advice.
- We can do that using a new parameter in the @PointCut annotation, called "returning".
- Then, we add a parameter to the advice of the SAME type as the return type, and the name is the SAME name as the one we passed to the "returning" argument in the @PointCut annotation.
- The return type will be injected in that new parameter.

**In Code** <br/>
**Step 1** <br/>
First, we'll create an Account class:
- Two fields, string name, string level.
- no arg constructor, constructor with fields.
- getters, setters.
- toString.
``` Java
public class Account {
	private String accountName;
	private String level;
	
	public Account() {
		
	}
	
	public Account(String accountName, String level) {
		this.accountName = accountName;
		this.level = level;
	}

	public String getAccountName() {
		return accountName;
	}

	public void setAccountName(String accountName) {
		this.accountName = accountName;
	}

	public String getLevel() {
		return level;
	}

	public void setLevel(String level) {
		this.level = level;
	}

	@Override
	public String toString() {
		return "Account [accountName=" + accountName + ", level=" + level + "]";
	}
}
```

**Step 2** <br/>
In AccountDAO, add a new method findAccounts(), returns a List of accounts.
``` Java
@Component
public class AccountDAO {
	public void addAccount(Account t, int j) {
		System.out.println("Now, I'm in the main function");
	}
	
	public List<Account> findAccounts() {
		List<Account> accounts = new ArrayList<>();
		
		// this is some sample code, we'll just add some accounts
		accounts.add(new Account("Bugs Bunny", "1"));
		accounts.add(new Account("Daffy Duck", "2"));
		accounts.add(new Account("Mickey Mouse", "3"));
		accounts.add(new Account("Donald Duck", "4"));
		
		return accounts;
	}
}
```

**Step 3** <br/>
- In the main app, call the new method.

**Step 4** <br/>
- Create a new aspect class (or use an old one).
- Add a new method, annotate it with @AfterReturing.
- Pass two arguments to the annotation:
    - pointcut="": write the expression.
    - returning="": write any name.
- Add an argument of the same return type to the advice, and of the same name as the "returning" parameter in the annotation.
- Inside the method, add some stuff like:
    - Getting the method signature.
    - Print the result.
``` Java
@Aspect
@Component
@Order(1)
public class MyNewAspect {

	@Pointcut("execution(* com.luv2code.aopdemo.dao.AccountDAO.findAccounts(..))")
	public void myPointcut() {}
	
	@AfterReturning(
			pointcut="myPointcut()",
			returning="result")
	public void afterReturningAdvice(JoinPoint jp, List<Account> result) {
		String sig = jp.getSignature().toShortString();
		System.out.println("Method: " + sig);
		System.out.println("Result: " + result);
	}
}
```
Now run the method, and see the results :smile: <br/>

**How to modify the return value** <br/>
Remember the post-processing data we talked about earlier?
We can actually do that, in our example in the returning list, we can add items, remove items, update existing items.

BUT, **be careful**, if a developer who doesn't know AOP works on the code, they'll think that the code is broken somehow.
So, be VERY transparent with your team when you do that, tell them EVERY update, and make sure that all of them KNOW and UNDERSTAND the concepts of AOP.

**In Code** <br/>
- Go into your aspect, modify the "result" parameter, for example convert all of the accounts' names to uppercase or something:
``` Java
@Aspect
@Component
@Order(1)
public class MyNewAspect {

	@Pointcut("execution(* com.luv2code.aopdemo.dao.AccountDAO.findAccounts(..))")
	public void myPointcut() {}
	
	@AfterReturning(
			pointcut="myPointcut()",
			returning="result")
	public void afterReturningAdvice(JoinPoint jp, List<Account> result) {
		System.out.println("Original Result: " + result);
		
		convertAccountNamesToUppercase(result);
		
		System.out.println("Modified Result: " + result);
	}

	private void convertAccountNamesToUppercase(List<Account> result) {
		for(Account a: result) {
			a.setAccountName(a.getAccountName().toUpperCase());
		}
	}
}
```
Run the main app :smile: <br/>

### @AfterThrowing Advice Type
This advice runs after the method if an exception is thrown.

**Use cases** <br/>
1. Logging the exceptions.
2. Audit the exception.
3. Notify DevOps team via mail or whatever. (Use this with care, for very critical exceptions only i.e. don't spam xD)

Usage is the same as before, using an annotation @AfterThrowing, and passing in our pointcut expression.

**Can we access the exception?** <br/>
Yes, we can, remember the "returning" argument we passed to @AfterReturning, then added a parameter to the aspect that matches the return type? <br/>

Same concept, we add "throwing" arg to the annotation, giving it any name, then adding a new parameter to the aspect of type Throwable, and name is the same as the one we passed to "throwing" in the annotation.
``` Java
@AfterThrowing(
	pointcut="myPointcut()",
	throwing="exc")
public void afterReturningAdvice(JoinPoint jp, Throwable exc) {
	// do stuff with the exception exc
}
```
By the way, we are only reading the exception, but it STILL propagates to the main app, we don't handle it in the aspect.
We just peak at it before it goes to the main app.

If we want to STOP the exception propagation, we'll have to use the @Around advice type, we'll check that out later.

**Development Steps:**
1. In main app, add a try-catch block.
2. In AccountDAO, we'll modify the function to throw an exception.
3. Add the @AfterThrowing advice.

**In Code** <br/>
**Step 1** <br/>
- In the main app, add a try-catch block.
- Inside it, call any method from AcoountDAO, or make a new function that just throws an exception, I did that:
``` Java
public class MainDemoApp {

	public static void main(String[] args) {
		AnnotationConfigApplicationContext context = 
				new AnnotationConfigApplicationContext(DemoConfig.class);
		
		AccountDAO accountDAO = context.getBean("accountDAO", AccountDAO.class);
		
		try {
			accountDAO.throwExceptionMethod(true);
		} catch(Exception e) {
			e.printStackTrace();
		}
		
		context.close();
	}

}
```
**Step 2** <br/>
- In AccountDAO, either throw an exception in the function you used in the main app, or make a new function.
- I created a new function that just throws an exception when I pass "true" to it.
``` Java
@Component
public class AccountDAO {
	...

	public void throwExceptionMethod(boolean tripwire) throws Exception {
		if(tripwire)
			throw new Exception("I'm an exception and I love introspection.");
		return;
	}
}
```
**Step 3** <br/>
- In your aspect, add an adviec and annotate it with @AfterThrowing.
- Pass in a pointcut expression that matches the function that throws an exception.
- Pass in "throwing" and give it any string value.
- In the advice, add a new parameter of type Throwable, and of name the same as the string value we gave to "throwing".
- sysout anything in the aspect.
``` Java
@Aspect
@Component
@Order(1)
public class MyNewAspect {

	...
	
	@Pointcut("execution(* com.luv2code.aopdemo.dao.AccountDAO.*(..))")
	public void myPointcut2() {}
	
	...
	
	@AfterThrowing(
			pointcut="myPointcut2()",
			throwing="exc"
			)
	public void afterThrowingAdvice(JoinPoint jp, Throwable exc) {
		System.out.println("The exception thrown says: " + exc.getMessage());
	}

	...
}
```
Run the main app now, check the output and when the aspect runs.
Also, check that the exception still propagates to the main app.

### @After Advice Type
This advice runs after the method regardless of it runs or throws an exception, basically it's like the finally block.

So, our code in the @After advice should depend on **neither** the happy **nor** the exception paths of the method.

The @After advice will execute BEFORE @AfterThrowing.

But, unlike @AfterThrowing the @After advice don't have access to the exception.

The @After advice still has access to the JoinPoint.

It's preferred to do the logging and auditing here in the @After advice.

**Use cases** <br/>
1. Logging and auditing as usual.
2. Closing resources or any other code that runs regardless of the outcome of the method.

**Development Steps:**
1. Add the @After advice.
2. Test the advice at success and at failure.

**In Code** <br/>
**Step 1** <br/>
- In your aspect, add an adviec and annotate it with @After.
- Pass in a pointcut expression that matches the function that throws an exception.
- sysout anything in the aspect.
``` Java
@Aspect
@Component
@Order(1)
public class MyNewAspect {

	...
	
	@After("myPointcut2()")
	public void afterAdvice() {
		System.out.println("The after advice is running now.");
	}
}
```
**Step 2** <br/>
- In the main app, in the function that throws an exception if you give it true, give it false.
``` Java
public class MainDemoApp {

	public static void main(String[] args) {
		...
		
		try {
			accountDAO.throwExceptionMethod(false);
		} catch(Exception e) {
			e.printStackTrace();
		}
		
		context.close();
	}

}
```
Run the app, see that the @After advice runs. <br/>

**Step 3** <br/>
- In the main app, in the function that throws an exception, now give it true.
``` Java
public class MainDemoApp {

	public static void main(String[] args) {
		...
		
		try {
			accountDAO.throwExceptionMethod(false);
		} catch(Exception e) {
			e.printStackTrace();
		}
		
		context.close();
	}

}
```
Run the app, see the the @After advice still runs, and it runs before the @AfterThrowing advice.

### @Around Advice Type
It runs before and after the method, regardless of the output. <br/>

Wait what? xD <br/>
- Main app calls target object.
- Around advice runs.
- Method runs.
- Around advice runs *again*.
- Control goes back to main app.

So basically if you use the Yu-gi-oh fusion card "Polymerization" to fuse @Before and @After advices, you get the @Around advice xD

***Note for Yu-gi-oh fans who are kinda beginners***
(You can also fuse monster cards if you have the field card "Fusion Gate" which allows fusion to happen even if you don't have the polymerization card, which is useful but if you opponent has good fusion monsters, it can turn into a disadvantage, so be careful when using it) 

Use cases:
1. Logging, auditing, security.
2. Pre-processing and post-processing data.
3. Profiling of the code.
4. Managing exceptions (Contrary to @AfterThrowing, the @Around advice can manage exceptions instead of the main app).

**ProceedingJoinPoint** <br/>
ProceedingJoinPoint is a subclass of JoinPoint that can be used to actually execute the target method itself, this is used to profile code.

We'll use the @Around advice to profile some code.

**Development Steps:**
1. Create a new function in AccountDAO that does some work.
2. Create the @Around advice.
3. Call the new AccountDAO function in the main app.

**In Code:** <br/>
**Step 1** <br/>
- In AccountDAO, create a new function.
- Inside it, open a try-catch block.
- Inside the block, use TimeUnit to make a delay, make it 5 seconds or whatever.
- sysout anything inside it so that we can trace the times the @Around advice executes.
- Also return a string from it.
``` Java
@Component
public class AccountDAO {
	...
	
	public String waitSomeTime() {
		try {
			TimeUnit.SECONDS.sleep(5);
			System.out.println("Finished the wait,");
			
		} catch(Exception e) {
			e.printStackTrace();
		}
		return "This is how we do it!";
	}
}
```

**Step 2** <br/>
- In your aspect, create a new advice, annotate it with @Around, pass in the pointcut.
- Add a new argument to the advice, of type ProceedingJoinPoint.
- Now, inside the advice, we'll do some fancy stuff, we'll profile the target method.
	1. sysout anything to identify the @Around advice before the target method.
	2. Create a "long" variable, use System.currentTimeMillis() to get the current time.
	3. Use the ProceedingJoinPoint to invoke the target method using the method proceed(), return the result in a variable of type Object.
	4. Create another long variable, initialize it with the current time AFTER the proceed().
	5. sysout the difference between the two variables i.e. the time taken by the target method.
	6. return the Object that contains the return value of the target method.
``` Java
@Aspect
@Component
@Order(1)
public class MyNewAspect {

	@Pointcut("execution(* com.luv2code.aopdemo.dao.AccountDAO.*(..))")
	public void aroundPointcut() {}
	
	@Around("aroundPointcut()")
	public Object aroundAdvice(ProceedingJoinPoint pjp) throws Throwable {
		System.out.println("Executing @Around advice before the target.");
		
		long begin = System.currentTimeMillis();
		
		Object result = pjp.proceed();
		
		long end = System.currentTimeMillis();
		
		System.out.println("The time taken by the target method is: " 
				+ Math.abs(end - begin)/1000.0);
		
		return result;
	}
}
```

**Step 3** <br/>
- In the main app, call the new function.
``` Java
public class MainDemoApp {

	public static void main(String[] args) {
		...
		
		accountDAO.waitSomeTime();
		
		context.close();
	}

}
```
Run the app, check the output and check when the @Around advice runs, and its output :smile: <br/>

#### Output problems
If the print order is strange or out of the expected order, it may be because:
1. Spring prints to the Logger output stream.
2. sysout prints to the Standard output stream.

These are two different output stream.

To solve this, we'll use the Logger output stream.

**How?** <br/>
We'll use a Java Logging APi, a standard API in Java.
Check Java Core notes, section Logging, for detailed info about the Jave Logging API. <br/>

**Development Steps:**
1. Create a static Logger variable "myLogger", use the Logger class to get a logger for the main app class.
2. Select a sysout function name "System.out.println", click ctrl+F (Find/replace).
3. Replace it (Replace All) with myLogger.info.
4. Do the same for all the other classes.
In the main app it looks like this:
``` Java
public class MainDemoApp {

	// static logger variable, passing in
	// the current class's .class.getName()	
	private static Logger myLogger = Logger.getLogger(MainDemoApp.class.getName());

	public static void main(String[] args) {
		AnnotationConfigApplicationContext context = 
				new AnnotationConfigApplicationContext(DemoConfig.class);
		
		AccountDAO accountDAO = context.getBean("accountDAO", AccountDAO.class);
		
		// replacing sysout with myLogger.info
		myLogger.info(accountDAO.waitSomeTime());
		
		context.close();
	}

}
```
The same process for other classes.
Run the app now and check the order of the output :smile: <br/>

***Note:*** the output will be red and will be proceeded by "INFO:", that's normal. I know how developers are sensitive to the red colored font, we see it in our nightmares, man xD <br/>

#### Handling Exceptions with @Around advice
Unlike the @AfterThrowing advice, we can actually handle exceptions in the @Around advice.

We can handle it, so that the main program never knows that an exception is thrown, or rethrow it to the main program.

**A) Handling the Exception** <br/>
Inside the @Around advice, we surround the .proceed method with try-catch block and actually handle the exception there.

In the catch block, we assign a default value to the result variable that holds the return value of the target function (because it threw an exception so now it's no assigned), then return the default result.

When to do that?
- You're a developer, and in your job you encounter problems.
- If you encountered a problem that's a minor problem, you can handle it yourself without alerting the manager.
- But, if it's a sever problem that happens all the time, you may want to alert your manager.

The manager is the main app, and you are the @Around advice, you handle the problem if it's a small problem, but if it's a big problem then rethrow it to the main app.

There is no right or wrong answer, but usually handling exceptions in the advice is like making a workaround, which is useful for some cases, but some others require the root cause to be solved.

**In Code** <br/>
**Step 1** <br/>
First, in the main app, instead of waitSomeTime, call the function that throws an exception if true is passed to it, pass true to it.

Then, in the AccountDAO, in that function, modify it so it returns a string if successful, and return any string.

**Step 2** <br/>
- In the aspect, in the @Around advice, surround the .proceed with a try-catch block.
- In the catch block, handle the exception and assign a default value to the result variable.
- [Optional] Use myLogger.warning to notify the user of the error that occured.
``` Java
@Aspect
@Component
@Order(1)
public class MyNewAspect {

	private static Logger myLogger = Logger.getLogger(MyNewAspect.class.getName());

	@Pointcut("execution(* com.luv2code.aopdemo.dao.AccountDAO.*(..))")
	public void aroundPointcut() {}
	
	@Around("aroundPointcut()")
	public Object aroundAdvice(ProceedingJoinPoint pjp) throws Throwable {
		Object result = null;
		
		try {
			result = pjp.proceed();
		} catch (Exception e) {
			myLogger.warning("Error during execution, returning default value.");

			result = "The default value.";
		}
		
		return result;
	}
}
```
Now run the main app, and check that the output does NOT contain the stack trace (we didn't print it in the aspect).
Even if we wrote e.printStacktrace in the main app, the main app never knew that an exception was thrown, we just displayed a warning.
Which is what we want :smile: <br/>

**B) Rethrowing the Exception**
Instead of handling the exception in the advice, we'll log it, then rethrow it to the main app, and the main app will handle it.

**In Code** <br/>
A very simple change, in the @Around advice, instead of assigning a default value to the result, throw the exception you received.
``` Java
@Aspect
@Component
@Order(1)
public class MyNewAspect {

	private static Logger myLogger = Logger.getLogger(MyNewAspect.class.getName());

	@Pointcut("execution(* com.luv2code.aopdemo.dao.AccountDAO.*(..))")
	public void aroundPointcut() {}
	
	@Around("aroundPointcut()")
	public Object aroundAdvice(ProceedingJoinPoint pjp) throws Throwable {
		Object result = null;
		
		try {
			result = pjp.proceed();
		} catch (Exception e) {
			myLogger.warning("Error during execution, returning default value.");

			// that's it xD
			throw e;
		}
		
		return result;
	}
}
```
That's it, run the program, check the output, you'll see the stack trace printed because the main app printed it :smile: <br/>

---

# And now, we are DONE
^_^
