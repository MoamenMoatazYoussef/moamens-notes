# Microservices Using Spring Boot
## Table of Contents
## Tips

## Introduction
**What is a web service anyway?** <br/>
A formal definition of a web service is a "service" that is communicated over the web.

**What's a simpler way to say it?**<br/>
When you open your PC, and you open Youtube, what appears to you is the homepage of Youtube with recommended videos, your subscriptions' videos, etc.

What happened between you and the PC is that you opened youtube.
What happened between your PC and the Youtube server may be much more.

For example, the Youtube server may request your username and password, so your PC sends them over.

If you search youtube for something, that string you wrote in the search bar is send by your PC to the server, where the server searches and does a lot of stuff, before getting a list of videos that match your search string, and sends them back, where they are rendered on your PC to look like the list we know today.

The server requested your user & pass.
Your PC requested a list of things that match a string.
The server sent a list of things that match that string.

So, we can say that Youtube offers a search service for users.
The communication between your PC and Youtube is in the form of requests, responses, etc.

These are "Services" between your PC and the server, over the internet.

That is a *Web service*.

A *Web service* is a piece of software that runs on a computer, and offers to run some software logic, or *"service"* to other computers, communicating with each other over some network.

Web services are:
- designed to be communicated between machines, PCs, computers, **applications running on computers**, not human beings (Yes, you type the search string and press enter, but your PC does all the work from that point on).
- are communicated over a Network, be it the internet or any other network.
- not platform dependent, ANY machine in the world should be able to send Youtube servers search requests.

**How does PCs or applications send and receive data to and from each other?** <br/>
Your PC and the Youtube server are connected, but to get search results:
- Your PC needs to tell the server "I want videos that match this string". This is called a *Request*.
- The server does its logic.
- The server tells your PC "I got the videos you requested, here it is", this message is sent to your PC along with the list of videos. This is called a *Response*.

This means, that for a web service to be platform independent (one of its properties we said earlier), the format of Requests and Responses should not depend on the sending pc or receiving server's specifications.

So, the formats of Requests and Responses should be standardized.

The two standard formats for Requests and Responses are:
1. XML: eXtensible Marup Language, this can be generated from any application on any PC, whether the application is a Java app, a PHP app, etc.

Also this can be sent by any PC, be it the Titan Supercomputer or a nokia 6600.

2. JSON: JavaScript Object Notation, same thing, can be sent by any application on any PC.

**So how does your PC or the server know the format?** <br/>
When your PC and the server are connected, they sign a contract between each other, this contract specifies:
- the **format** that is used by Requests and Responses,
- the **structure of the request** that the PC should send to the server,
- the **structure of the response** that should be expected by your PC, and
- the **endpoint** of the service, *what URL should I use to request the service?*.

This contract is called a *Service Definition*.

The format used by Requests and Responses is called the *Message Exchange Format*.

Your PC is a *service consumer*, it Consumes the service offered by the server.

The Youtube server is the *service provider*, it hosts the service and listens for requests by any connected PC.

**How are web services called through their endpoints?**
Endpoint: the URL of the service that your PC uses to send a request to the server.

Your PC is using the internet to do that, it's using *HTTP requests* to call that service.

There is another way for web services, a **Queue**.
- Service consumer places a message on the queue.
- Service provider listens to the queue, 
- as soon as it gets the message from the queue, it takes the request, do the logic, creates the response, then puts it in the queue,
- the service consumer listens to the queue, until it gets the response.

So, web services are communicated through:
- HTTP, over the internet.
- MQ, over queues in the network.

This is called *transport*.

**Recap** <br/>
- Your PC connects to the server.
- Your PC and the server sign a contract, a *service definition*, that specifies how the web service is offered to your PC.
- You search for a string and press enter.
- Your PC reads the *service definition* to know what *message exchange format* the web service expects.
- Then, your PC takes your string, along with other data, and organizes it in the format specified by the *service definition*.
- Your PC then reads the *service definition* to know what is the *endpoint* of the service, how can we reach that service.
- Your PC then uses that *endpoint* to call the service, since this is the internet, the service is called in a specific way, a *transport*, called HTTP.

### Types of Web Services
Web services are divided into two types:
- SOAP.
- REST.

**Wait what?**
Basically, XML is a markup language, it's a format, but it doesn't specify a specific **structure** of a message.

Therefore, there is a standard structure written in XML for web services, this is called a *Simple Object Access Protocol*, or *SOAP*.

*SOAP* is a specific XML structure that is used by web services, it consists of three main parts:
- **Header:** this doesn't contain your actual message, it contains data needed by the two machines to communicate with each other, like authentication, authorization, etc.
- **Body:** this is where you put your actual message, the search string is put here.
- **Envelope:** an element that is wrapper for the whole message, it contains the Header and the Body.

Messages that are structured in a SOAP structure, or *SOAP messages*, can be sent through any type of *transport* i.e. HTTP or MQ (Queues).

**Service Definition in SOAP** <br/>
Remember the contract signed by your PC and the youtube server? the *service definition*.

If your PC and the server communicate using *SOAP messages*, the *service definition* is written in an XML-based language, called *Web Service Definition Language* or *Web Service Description Language*, or just **WSDL**.

**There is another type of web services, specific to HTTP transport** <br/>

HTTP messages actually consist of several parts:
1. HTTP body: the message send by your PC or the server.
2. HTTP Method: this indicates what you want to do with the data:
    - GET: you want the server to fetch you some data.
    - POST: you want to add some new data in the server.
    - PUT: you want to update some existing data in the server.
    - DELETE: you want to remove some existing data from the server.
3. HTTP Status Code: this indicates the status of the service call, for example:
    - 200: this means that the call was successful.
    - 404: this means that what you requested was not found (I know you've seen this error before xD)

Web services should be designed to use all three parts of HTTP in order to communicate effectively

To fill all HTTP parts, a web service must adhere to some constraints, these constraints are grouped together in a software architecture called *REpresentational State Transfer* or *REST*.

Web services that are designed according to *REST* concepts are called *RESTful* web services.

**What are the *REST* constraints that web services should adhere to?** <br/>
- When we say a "Resource", we mean anything that you want to expose to the world using your app, for example the videos on youtube, the list of videos itself, etc.
- Each one of these videos **must be identified** by something that is unique, a *Unique Resource Identifier*, a *URI*.
- Since web services should be compatible with HTTTP, they **must support** all HTTP methods i.e. they should support:
    + Creation of data (POST).
    + Fetching of data (GET).
    + Updating of data (PUT).
    + Deletion of data (DELETE).

So, a *RESTful* web service must:
- Have a *Unique Resource Identifier*, a *URI*.
- Support all HTTP methods.

***Note:*** Unlike SOAP, *REST* doesn't care about the format of your message, be it XML, JSON, etc., it defines how this message is communicated across the network.

RESTful web services don't have a standard *service definition* language like SOAP, which has *WSDL*.

But, there are definitions for RESTful web services, like WADL and Swagger, here we'll use Swagger.

In this course, we'll use web services in Spring Boot.

## RESTful Web Services with Spring Boot

### Creating Simple RESTful Services
To develop a RESTful Web Service, we have to specify:
    - What kind of request is it? (GET, POST, etc.)
    - What is its URI?

So what are we going to do now? <br/>
We have a list of users, each user creates posts.

This means that the relationship between User and Post is one-to-many.

Also, posts can't exist without users.
Therefore, when we retrieve posts, we'll have to specify a user. (Not a *must* requirement in the real world, but we'll use it to specify URIs for each service)

We will create RESTful web services, mainly the four main requests:
- Get the entire list of users:
    + GET request.
    + URI: /users.
- Create a user: 
    + POST request.
    + URI: /users.
- Get a single user: 
    + GET request,.
    + URI: /users/{id} where {id} is the id of the user we want.
- Delete a single user: 
    - DELETE request.
    -  URI: /users/{id}.

Also, we'll create web services for posts by users:
- Retrieve all posts for a user:
    + GET.
    + /users/{id}/posts
- Create a post for a user:
    + POST.
    + /users/{id}/posts
- Retrieve details for a post:
    + GET.
    + /users/{id}/posts/{post_id}

Finally, we'll focus on:
    - Validation,
    - Internationalization.
    - Exception handling.
    - Versioning services,
    - and other things.

**Prep for our first project** <br/>
First, we'll create a new Spring Boot project:
- Go to Spring Initializer: https://start.spring.io/
- Create a new project:
    - Maven
    - Spring anything greater than 2.2.0 snapshot.
    - Coordinates:
        - groupId: com.in28minutes.rest.webservices
        - artifactId: restfulwebservices
    - Dependencies:
        - Spring web
        - Devtools
        - JPA
        - H2
- Generate the project.
- Import it as an Existing Maven Project to Eclipse.
- Wait until Eclipse downloads the dependencies.
- Go to the main class in src/main/java and run the app as a Java application.
- Go to a browser and open localhost:8080 to check that the app is running successfully.

#### First Steps
**Hello World RESTful Web Service** <br/>
- Create a new package "com.in28minutes.rest.webservices.controller".
- In it, create a new class HelloWorldController.
- Instead of @Controller, annotate it with @RestController, this annotation tells Spring that this class will handle REST requests.
- To create a REST service, we need to define:
    + What method,
    + URI.
- For our first service, we'll use method GET and URI /hello-world.
- Create a new method that returns a String "hello-world".
- Annotate the method with @RequestMapping, passing in the method to "method" argument, and the URI to "path" argument, or just annotate it with @GetMapping.
``` Java
@RestController
public class HelloWorldController {

	@GetMapping(path="/hello-world")
	public String HelloWorld() {
		return "Hello World";
	}
}
```
Run the app, then open localhost:8080/hello-world in a browser, see the output :smile:

**Creating an bean and returning it** <br/>
Instead of returning a string, we'll try to return a Bean, an Object that has a string field inside it.
- Create a similar method, HelloWorldBean.
- Map it to /hello-world-bean
- change the return type to HelloWorldBean.
- return new HelloWorldBean("Hello World Bean").
- An error will show because HelloWorldBean isn't defined yet, create a new class HelloWorldBean.
- Add a private string field "message",
- Add getters & setters for it.
- Add a constructor setting the message field.
- Add a toString method.
``` java
public class HelloWorldBean {
	private String message;

	public HelloWorldBean(String message) {
		super();
		this.message = message;
	}

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

	@Override
	public String toString() {
		return "HelloWorldBean [message=" + message + "]";
	}
}
```
Go back to the browser, then open localhost:8080/hello-world-bean in a browser, see the output :smile:

***Note:*** This will display an error if we don't create a getter for the field message.

**So what's happening in the background?** <br/>
Spring Boot does some auto-configuration, it configures many objects like:
- **dispatcherServlet**: this is the class responsible for taking incoming URIs, mapping them to the right methods in Controller classes, and mapping the output of those methods to view pages.
- **HttpMessageConverters**: these are classes responsible for transforming beans to JSON and vice versa, an example class is Jackson2ObjectMapper.

So, Spring Boot autoconfigures all of that stuff, then when we go to localhost:8080/hello-world-bean:
1. This URI goes to dispatcherServlet.
2. dispatcherServlet searches @RestController(s) for methods that map to this URI, and determines that the method HelloWorldBean maps to the URI /hello-world-bean.
3. This method is executed and returns a bean.
4. The original @RestController interface has an annotation @ResponseBody, this makes the response from any class annotated by @RestController be converted to some other format by one of the HttpMessageConverters.
5. So, the returned bean goes into one of the HttpMessageConverters and is converted to a JSON object that can be displayed.
6. Then, dispatcherServlet determines the view page that will return with the output.
7. Finally, the selected view page is returned and viewed on the browser.

**Adding Path variable to the mapping** <br/>
All the URIs we mapped so far were hardcoded by us. What if we want to map something that changes?
- In Eclipse, in the HelloWorldController class, create a new method, similar to the previous ones.
- In the @GetMapping or @RequestMapping annotation in the path argument, make it "/hello-world-bean/path-variable/{name}".
- In the method signature, add a String argument called "name", the same as in the path argument.
- Before it, put an annotation @PathVariable, so that this argument gets mapped to the path argument in the @GetMapping annotation.
- Inside the method itself, you can put the name argument in the string of the bean.
``` Java
@GetMapping(path="/hello-world-bean/path-variable/{name}")
public HelloWorldBean HelloWorldBean(@PathVariable String name) {
	return new HelloWorldBean("Hi, " + name);
}
```

Now, go to localhost:8080/hello-world-bean/path-variable/<any name you want>, try different names, every time you should see a JSON object containing the name :smile: <br/>

This type of path variable will be used extensively.

#### Creating the Entity Class
Now, we'll add the User class and services necessary for the User.

***Note:*** for now, we'll store User objects in an arrayList, after a while we'll use JPA to store them in a DB. 

**Step 1** <br/>
- Create a new package "com.in28minutes.rest.webservices.restfulwebservices.entity".
- In it, create a new class User.
    - int id
    - String name
    - Date birthday
    - getters and setters
    - constructor using fields
    - toString
``` Java
public class User {
	private int id;
	private String name;
	private Date birthday;
	
	public User(int id, String name, Date birthday) {
		super();
		this.id = id;
		this.name = name;
		this.birthday = birthday;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Date getBirthday() {
		return birthday;
	}

	public void setBirthday(Date birthday) {
		this.birthday = birthday;
	}

	@Override
	public String toString() {
		return "User [id=" + id + ", name=" + name + ", birthday=" + birthday + "]";
	}
}
```

**Step 2** <br/>
- Create a new package "com.in28minutes.rest.webservices.restfulwebservices.dao"
- In it, create a new generic interface BaseDAO<T>:
    - method: get users
    - method: get one user by id
    - method: save user
    - method: delete user by id
``` Java
public interface BaseDAO<T> {
	public List<T> findAll();
	
	public T get(int id);
	
	public T save(T t);
	
	public void delete(int id);
}
```

**Step 3** <br/>
- Create a new interface UserDAO that implements BaseDAO<User>:
    - static list<User>
    - static int to hold the number of users in the list.
    - static block, init some users.
    - method: get users: return the list.
    - method: get one user by id: get one from the list.
    - method: save user: save user to the list or update if existing.
    - method: delete user by id: remove a user from the list.
- for now annotate it with @Component (after that we'll change that to @Repository when we use JPA).
``` Java
@Component
public class UserDAO implements BaseDAO<User> {
	private static List<User> users = new ArrayList<>(); //TODO: replace with DB
	
	private static int usersCount = 4; //TODO: replace with DB
	
	static { //TODO: replace with DB
		users.add(new User(1, "Max", new Date()));
		users.add(new User(2, "Payne", new Date()));
		users.add(new User(3, "Mona", new Date()));
		users.add(new User(4, "Sax", new Date()));
	}
	
	@Override
	public List<User> findAll() {
		return users;
	}

	@Override
	public User get(int id) {
		for(User user: users) {
			if(user.getId() == id) {
				return user;
			}
		}
		return null;
	}

	@Override
	public User save(User t) {
		if(t.getId() == null) {
			t.setId(++usersCount);
		}
		users.add(t);
		return t;
	}

	@Override
	public void delete(int id) {
		for(User user: users) {
			if(user.getId() == id) {
				users.remove(user);
				return;
			}
		}
	}

}
```

**Optional Step** <br/>
- Create a new package "com.in28minutes.rest.webservices.restfulwebservices.service"
- In it, create a new generic interface BaseService<T>:
    - method: get users
    - method: get one user by id
    - method: save user
    - method: delete user by id
``` Java
public interface BaseService<T> {
	public List<T> findAll();
	
	public T get(int id);
	
	public T save(T t);
	
	public void delete(int id);
}
```

- Create a new interface UserService that implements BaseService<User>.
- add a private BaseDAO<User>, @Autowired.
- Create these methods:
    - findAll()
    - get(int id)
    - save(User t)
    - delete(int id)
    All of these methods call the respective method using the BaseDAO<User> object.

- for now annotate it with @Component (after that we'll change that to @Service when we use JPA).
``` Java
@Component
public class UserDAO implements BaseDAO<User> {
	private static List<User> users = new ArrayList<>(); //TODO: replace with DB
	
	private static int usersCount = 4; //TODO: replace with DB
	
	static { //TODO: replace with DB
		users.add(new User(1, "Max", new Date()));
		users.add(new User(2, "Payne", new Date()));
		users.add(new User(3, "Mona", new Date()));
		users.add(new User(4, "Sax", new Date()));
	}
	
	@Override
	public List<User> findAll() {
		return users;
	}

	@Override
	public User get(int id) {
		for(User user: users) {
			if(user.getId() == id) {
				return user;
			}
		}
		return null;
	}

	@Override
	public User save(User t) {
		if(t.getId() == null) {
			t.setId(++usersCount);
		}
		users.add(t);
		return t;
	}

	@Override
	public void delete(int id) {
		for(User user: users) {
			if(user.getId() == id) {
				users.remove(user);
				return;
			}
		}
	}

}
```

**Step 4** <br/>
- In the controller package, create a new Controller "UserResource".
- Annotate it with @RestController.
- Add a private field of BaseDAO<User> (or BaseService<User> if you did the optional step), annotate it with @Autowired.
- Create methods to do this:
    - retrieve all users.
    - retrieve user by id.
``` Java
@RestController
public class UserResource {
	
	@Autowired
	public BaseService<User> userService;

	@GetMapping("/users")
	public List<User> getAllUsers() {
		return userService.findAll();
	}
	
	@GetMapping("/users/{id}")
	public User getUser(@PathVariable int id) {
		return userService.get(id);
	}
}
```
Now go to localhost:8080/users, you should see json objects containing all the users.
Try to go to localhist:8080/users/2, see that the only user 2 is displayed.

Nice :smile: <br/>


#### Saving Entities
Okay, so how do we save users?
By using a POST request, to the URI of the DB of users (in our case so far, a list), the URI is /users.

If you open Chrome Dev Tools (F12 or right-click -> inspect), go to the network tab, you can see the HTTP requests and responses.

In GET requests, Spring MVC responses with an HTTP status code: 200 OK, which means "Successful Request".

In POST requests, we want to get a different status code which means "Created", and the response should return the newly created user's URI.

**In Code** <br/>
- Go to eclipse, in the Controller class UserResource.
- Create a new method "createUser" or "saveUser", which has a User argument.
- Annotate it with @PostMapping("/users"), passing in the URI of the users list.
- Annotate the User argument of the method with @RequestBody, this annotation means that the POST request will have a body that contains a User object (that is because we'll send a user to be created).
- Inside the method, just use the service to save the User argument and return the User object returned.
``` Java
@RestController
public class UserResource {
	
	@Autowired
	public BaseService<User> userService;

	@GetMapping("/users")
	public List<User> getAllUsers() {
		return userService.findAll();
	}
	
	@GetMapping("/users/{id}")
	public User getUser(@PathVariable int id) {
		return userService.get(id);
	}
	
	// here it is
	@PostMapping("/users")
	public User saveUser(@RequestBody User user) {
		return userService.save(user);
	}
}
```
**Now, how do we send POST requests?** <br/>
To send POST reviews, we'll use a chrome extension called Postman, go to chrome and install it.

In Postman, enter the url localhost:8080/users, choose POST request, then go to the tab Body, inside it put a JSON object with "name" and "birthday" fields and values.

Now, when you click *Send*, you'll encounter an error "Internal Server Error", that is because we don't have a no-arg constructor for the entity we're trying to add, which is User.

Add a no-arg constructor to User and try sending again with Postman.

You'll see status code 200 OK, now go reload localhost:8080/users, you'll see the new user with an automatically created ID :smile: <br/>

Real nice :smile: <br/>

Well...not "real nice", because we want the status CREATED, not the status OK..

Also, we didn't return the created user in the response.

Can we return the status CREATED and put the created user in the response?

**Yes** <br/>
We want to do two things:
1. Return the status code CREATED.
2. Return the newly created user's URI.

To do that, we'll use a Spring object called ResponseEntity<T>, we'll call its method .created(), this method will return the status code CREATED.

This method also takes an argument "location", which is the URI of the new user, to be returned with the status CREATED.

So, inside this method we should pass the URI of the new user.

How do we get the URI of the new user?
By using another Spring object called ServletUriComponentsBuilder, this object has several methods we'll use.

First of all, we need the URI to be /users/{id} i.e. we need to append the id of the new User object to the current request URI /users.

So:
1. we'll use the method .fromCurrentRequest() to start from the current request URI, then 
2. we'll use .path("/{id}") to append the /{id} to the current request URI, then
3. we'll use the method .buildAndExpand(newUserObject.getId()) to pass the new id to the parameter {id}, finally
4. we'll use the method .toUri() to get the resulting Uri of the newly created user. 

**In Code** <br/>
- Go to UserResource class, to the method we just created.
- Instead of returning the User object, save it in a local variable "savedUser".
- Create a new local variable of type URI called location (or anything, I just called it location).
- Assign it to ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(savedUser.getId()).toUri();

Then,
- return ResponseEntity.created(location).build();
This build the response with the status code CREATED and the URI of the newly created user, which is our objective.
- Finally, change the method return type to RequestEntity<Object>.
``` Java

@RestController
public class UserResource {
	
	@Autowired
	public BaseService<User> userService;

	@GetMapping("/users")
	public List<User> getAllUsers() {
		return userService.findAll();
	}
	
	@GetMapping("/users/{id}")
	public User getUser(@PathVariable int id) {
		return userService.get(id);
	}
	
	// That was a lot of work right there xD
	@PostMapping("/users")
	public ResponseEntity<Object> saveUser(@RequestBody User user) {
		User savedUser = userService.save(user);
		
		URI location = ServletUriComponentsBuilder
				.fromCurrentRequest()
				.path("/{id}")
				.buildAndExpand(savedUser.getId())
				.toUri();
		
		return ResponseEntity.created(location).build();
	}
}
```
Now go to Postman, create a new user and send a POST request, check the status: 201 CREATED.

Go to the Headers tab, there's a field Location, which has the location of the newly created user.

Now that, is *Real nice* :smile: <br/>

#### Exception Handling - User Not Found
Try sending a GET request for a user that doesn't exist e.g. id = 500, from postman.

The response will surprose you:
Status: 200 OK.
Body: empty.

That's not right xD <br/>
If user isn't found, we shouldn't return a status OK, we should show an error indicating that this user doesn't exist.

Well, we can throw an error, but there is no specific error for users not found.

So, we'll have to create our own error to throw (yeah we're kind of psychos, we create our own errors xD)

**In Code** <br/>
- Create a new package "com.in28minutes.rest.webservices.restfulwebservices.myerrors"
- Create a new class UserNotFoundException that extends RuntimeException.

That would be enough since we have the capabilities of RuntimeException, but we can add some more by overriding the constructor by providing a message constructor.

- Create a constructor that overrides RuntimeException(String message).
- inside it, just use super(message).
``` Java
public class UserNotFoundException extends RuntimeException {

	public UserNotFoundException(String message) {
		super(message);
	}
	
}
```

Now, go back to the controller UserResource, modify the getUser function like this:
``` Java
@GetMapping("/users/{id}")
public User getUser(@PathVariable int id) {
	User retrievedUser = userService.get(id);
	if(retrievedUser == null) {
		throw new UserNotFoundException("User of id: " + id + " not found.");
	}
	return retrievedUser;
}
```

If we do a GET request using Postman now, we'll get 500 Internal Server Error.

That's...good, but not quite good, that is NOT a server error.

We need to return a response status that says that the user is not found.

To do that, annotate the UserNotFoundException with:
``` Java
@ResponseStatus(HttpStatus.NOT_FOUND)
```

Try the request again, you'll get status 404 Not Found (We are the one causing this error now, told you we are psychos xD)

The response body will have a structure provided by Spring that is a standard structure for exceptions.

Now that is really good :smile: <br/>

It's important to return the appropriate exception message in the response.
So, it's better to define a standard exception structure that you always follow when creating exceptions for web services.

***Note:*** the exception structure is usually standardized across the entire Organization.

**How do we create an Exception structure and override the standard one?** <br/>
- Create a new class ExceptionResponse.
- in it, we'll add the fields:
	- Date, to indicate when the error happened.
	- String, message.
	- String, details.

- Add a constructor using all fields.
- Generate getters and setters.
``` Java
public class ExceptionResponse {
	private Date timestamp;
	private String message;
	private String details;
	public ExceptionResponse(Date timestamp, String message, String details) {
		super();
		this.timestamp = timestamp;
		this.message = message;
		this.details = details;
	}
	
	public Date getTimestamp() {
		return timestamp;
	}
	public void setTimestamp(Date timestamp) {
		this.timestamp = timestamp;
	}
	public String getMessage() {
		return message;
	}
	public void setMessage(String message) {
		this.message = message;
	}
	public String getDetails() {
		return details;
	}
	public void setDetails(String details) {
		this.details = details;
	}
}
```

In Spring, there's an abstract class called ResponseEntityExceptionHandler, this can be extended to provide centralized exception handling for all our requests.

To make other exceptions conform to this structure, we'll extend this and implement our own exception handling functionality.

**In Code** <br/>
- Create a new class CustomizedResponseEntityExceptionHandler that extends ResponseEntityExceptionHandler.
- Annotate it with @RestController, because it provides responses back.
- Also, annotate it with @ControllerAdvice, this is an anootation that indicates that this class declares methods to be shared across classes.
- Now, to override the default exception handling, add a public final method, which returnes ResponseEntity<Object> called handleUserNotFoundException, taking two arguments of type Exception and WebRequest.
- Inside it, create an instance of our new exception structure ExceptionResponse using the constructor with fields.
	+ Get a new date
	+ Use the Exception argument to get the exception message
	+ Use the request to get the description and pass it to the details.
- Assign this to a local ExceptionResponse variable.
- Return a new ResponsEntity that takes two arguments in its constructor, the first is your exceptionResponse, the second is an httpStatus.
- Finally, annotate it with @ExceptionHandler, this indicates that the method annotated will be used to handle any exception whose class is passed to the annotation.
- Pass UserNotFoundException.class to the annotation to make this method handle any exception of type UserNotFoundException.
``` java
@ControllerAdvice
@RestController
public class CustomResponseEntityExceptionHandler extends ResponseEntityExceptionHandler {
	
	@ExceptionHandler(UserNotFoundException.class)
	public final ResponseEntity<Object> handleUserNotFoundException(Exception e, WebRequest request) {
		ExceptionResponse myResponse = new ExceptionResponse(
				new Date(), 
				e.getMessage(), 
				request.getDescription(false));
		
		return new ResponseEntity<Object>(myResponse, HttpStatus.NOT_FOUND);
	}
}
```

***Note:*** if you want this method to handle all exceptions, then pass Exception.class to the annotation instead of UserNotFoundException.class.

Now perform a new get request, see the structure of the error message :smile: <br/>

#### Deleting A User
That's a DELETE request, we'll use Postman to send it.
Well, we'll remove the user whose id is passed.
To do that we'll use a list iterator. (In the future, we'll delete it from the database)

We can return 200 OK status back, we can also return a status of "No Content".

**In Code** <br/>
- In the UserDAO, in the delete method, use an iterator to traverse the list and find the desired User, then remove it from the list and return it.
``` Java
	@Override
	public User delete(int id) {
		Iterator<User> it = users.iterator();
		
		while(it.hasNext()) {
			User user = it.next();
			if(user.getId() == id) {
				it.remove();
				return user;
			}
		}
		return null;
	}
```

***Note:*** you'll have to change the return type, also the return type of the method in the generic interface, the method in the generic service interface, and the method in UserService.

Then, 
- in the UserResource controller, add a new method deleteUser that takes int id as argument.
- Annotate it with @DeleteMapping("/users")
- Annotate the argument with @PathVariable.
- Use service to delete the user and get it.
- Throw a UserNotFoundException if user isn't found.
- [Optional] Use ResponseEntity's method .noContent.
``` Java
	@DeleteMapping("/users/{id}")
	public ResponseEntity<Object> delete(@PathVariable int id) {
		User user = userService.delete(id);
		if(user == null) {
			throw new UserNotFoundException("User of id: " + id + " not found.");
		}
		
		return ResponseEntity.noContent().build();
	}
```
Try deleting an existing user and check localhost:8080/users, then try deleting a non-existing user and check the response in Postman.

Nice :smile: <br/>

#### User Field Validation
Alright, so we implemented the CRUD services for User entity.
That's good, but we haven't validated any one of the User fields.
When we create a new user, we want to validate the user.

There are some javax.validation API annotations we'll use:
- @Valid: this means we want to validate this, we'll annotate the User argument in the controller method.
- @Size: this takes attributes to specify how big/small the input of that is, applied on the String name field of User.
- @Past: this indicates that the Date object should be in the past relative to the system time, applied on the Date birthday field of User. 

That's the controller method after adding @Valid:
``` Java
	@PostMapping("/users")
	public ResponseEntity<Object> saveUser(@Valid @RequestBody User user) {
		User savedUser = userService.save(user);
		
		URI location = ServletUriComponentsBuilder
				.fromCurrentRequest()
				.path("/{id}")
				.buildAndExpand(savedUser.getId())
				.toUri();
		
		return ResponseEntity.created(location).build();
	}
```

This is the User class after using @Size and @Past:
``` Java

public class User {
	private Integer id;
	
	@Size(min=2)
	private String name;
	
	@Past
	private Date birthday;

	...
}
```
Try sending POST responses to create users, but with name whose size is 1 or birthday which is in the future. You'll get status 400 Bad Request.

That's good, validation is working, but we need to deliver the specific error description.

We did that before, so we'll do something similar.

Remember the class ResponseEntityExceptionHandler? This class has a method handleMethodArgumentNotValud, this method is fired when a binding to a method argument fails i.e. Validation error.

So, we'll override this method in our CustomResponseEntityExceptionHandler class.
- Go to CustomResponseEntityExceptionHandler.
- Implement a new method protected ResponseEntity<Object> handleMethodArgumentNotValud(MethodArgumentNotValidException ex).
- Inside it, create a new ExceptionResponse, passing in a new Date(), ex.getMessage(),  
- and ex.getBindingResult().toString(), which has details of what went wrong.
- return a new ResponseEntity, passing in the ExceptionResponse object and HttpStatus.BAD_REQUEST.
``` Java
	@Override
	protected ResponseEntity<Object> handleMethodArgumentNotValid(
			MethodArgumentNotValidException ex, 
			HttpHeaders headers, 
			HttpStatus status, 
			WebRequest request) {
		ExceptionResponse myResponse = new ExceptionResponse(
				new Date(), 
				ex.getMessage(), 
				ex.getBindingResult().toString());
		
		return new ResponseEntity<Object>(myResponse, HttpStatus.BAD_REQUEST);
	}
```
***Note:*** Arguments in this method may differ due to different versions of Spring.

Try creating a user with invalid fields, see the error message now :smile: <br/>

You can even add a customized message for each field validation, for example:
- in the User object, in @Size, add an argument message="Name should have at least two characters".

Try creating a user again, see the error message.

***Get on my level*** :sunglasses: <br/>

***Note:***
- Check the javax.validation API for much more validation and error handling rules.
- Check the documentation of class ResponseEntityExceptionHandler to see how you can customize error and exception handling.
- Check Hibernate Validator, the most common validation handler used with Spring.

#### Adding HATEOAS
Usually, when a resource is requested, we don't just return that resource, we return other resources that might be helpful.

For example, if someone requests a User, I'll return that User, and a link to the list of users so that they can get all user details.

This concept is called *Hypermedia As The Engine Of Application States*, or *HATEOAS*.

If we want to implement our example: Requesting a user -> Return the user + link for list of users, we'll need a Spring Boot starter for that:
- Open pom.xml.
- Add the dependency:
``` xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-hateoas</artifactId>
</dependency>
```

This starter has:
- EntityModel<T>: a generic object representing any specific resource, we can pass a User object to it in the constructor.
- WebMvcLinkBuilder: a class that creates links from methods, how can we do that?
	+ First, we'll use .methodOn(), this method takes a method call as argument, and creates a Proxy of the method passed (proxy means a substitute of the original method, created so that we can modify that substitute without modifying the original)
	+ Then, we use .linkTo() and pass the returned proxy method, this creates a link to the method.
	+ Then, assign that to a local WebMvcLinkBuilder variable.
- Then, we'll use EntityModel.add() method to add the link to the EntityModel object, passing the link as argument and using link.withRel("The name we'll give to the link")
- Finally, return the EntityModel object.

***Note:*** WebMvcLinkBuilder is deprecated, use WebMvcLinkBuilder.

***Note:*** Resource<T> is deprecated, use EntityModel<T>.

Now, in the UserResource controller, in getUser method:
- Create a new EntityModel<User>, pass the retrieved user to the constructor.
- Create a new WebMvcLinkBuilder  variable.
- assign it to WebMvcLinkBuilder .linkTo(WebMvcLinkBuilder .methodOn(this.getClass()).getAllUsers());
- use entityModel.add() to add the link, use the withRel() to give the link a name.
- Return the EntityModel object instead of the User object, change the return type.
``` java
	@GetMapping("/users/{id}")
	public EntityModel<User> getUser(@PathVariable int id) {
		User retrievedUser = userService.get(id);
		if(retrievedUser == null) {
			throw new UserNotFoundException("User of id: " + id + " not found.");
		}
		
		EntityModel<User> resource = new EntityModel<>(retrievedUser);
		
		WebMvcLinkBuilder userLink = 
				WebMvcLinkBuilder.linkTo(
						WebMvcLinkBuilder
						.methodOn(this.getClass())
						.getAllUsers());
		
		resource.add(userLink.withRel("All Users"));
		
		return resource;
	}
```
Since we added a new dependency, we need Update Project (right-click on the project and choose Updat Project), then stop and restart the application.

Try getting a user and see the link.

Great :smile: <br/>

### Advanced RESTful Web Services
**Internationalization** <br/>
This means customizing your services to different people around the world, like chaning the language for example.

It can get complex if we're using many databases and stuff.

We'll try to internationalize the string "Hello world".

To do this, we'll use two classes:
- LocaleResolver: a class used to resolve the locale of the incoming request, we'll use that to get the country.
- ResourceBundleMessageSource: 

**Development Steps:**
1. Make a new bean using LocaleResolver.
2. Use that bean to set a default locale to US (basically we're setting the default language).
3. Create two properties files containing the same property good.morning.message=, for US and french locales.
4. Create another bean using ResourceBundleMessageSource.
5. Use that bean to customize properties files according to the locale. 

**In Code** <br/>
- We'll need to add a bean for the LocaleResolver.
- Go to the main app, create a method that returns LocaleResolver, annotate it with @Bean.
``` Java
@Bean
public LocaleResolver localeResolver() {
	SessionLocaleResolver localeResolver = new SessionLocaleResolver();
	localeResolver.setDefaultLocale(Locale.US);
	return localeResolver;
}
```

Then,
- Create a new file in src/main/resources called "messages.properties".
- In it, enter this:
```
good.morning.message=Good Morning
```
- Copy the file and paste it, renaming it message_fr.properties.
```
good.morning.message=Bonjour
```

Now, we need to read these properties and choose or customize them based on the input accepted.
For that, we'll need to define another bean.
- In the main app, define another method annotated with @Bean
- Returns ResourceBundleMessageSource
- create a ResourceBundleMessageSource local object.
- set its basename to "messages", the starting name of both properties files.
- return it.
``` Java
	@Bean
	public ResourceBundleMessageSource messageSource() {
		ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
		messageSource.setBasename("messages");
		return messageSource;
	}
```

Now, we need to update HelloWorldController to use  
<<< LEFTOVER: Will be continued later >>>

### XML Resources
So far, we've read and written Users using JSON.
What if we want to use XML? <br/>

In Postman, if we send a GET request and in the headers tab, we add a key Accept, and give itvalue application/xml, we'll get 406: Not Acceptable.

That's because XML isn't supported yet. <br/>

**How do we add support for XML?** <br/>
We need to make a simple JAR available in our POM file.
- We would want Jacksondataformat xml, so search for that in the Maven repo.
- You'll find that:
``` xml
<dependency>
  <groupId>com.fasterxml.jackson.dataformat</groupId>
  <artifactId>jackson-dataformat-xml</artifactId>
  <version>2.10.0</version>
  <type>bundle</type>
</dependency>
```
- Just add it to the POM file in the dependencies but remove the version and type elements:
``` xml
<dependency>
  <groupId>com.fasterxml.jackson.dataformat</groupId>
  <artifactId>jackson-dataformat-xml</artifactId>
</dependency>
```
- Restart the app, try the request again.

**Get on my powerlevel** :sunglasses: <br/>


### RESTful Documentation with Swagger
Swagger is a popular documentation format for RESTful services, since RESTful services are NOT standardized.



**How to add Swagger support to your app** <br/>
First, dependencies:
- Open the POM file.
- Add these dependencies:
``` xml
<dependency>
  <groupId>io.springfox</groupId>
  <artifactId>springfox-swagger2</artifactId>
  <version>2.6.1</version>
</dependency>

<dependency>
  <groupId>io.springfox</groupId>
  <artifactId>springfox-swagger-ui</artifactId>
  <version>2.6.1</version>
</dependency>
```

Now, configuring Swagger:
- Create a new class SwaggerConfig
- Declare it as a configuration class
- Enable Swagger using an annotation @EnableSwagger2
- inside the class, add a method api, no args, and returns an object called a Docket.
- Annotate that method with a @Bean
- return new Docket(DocumentationType.SWAGGER_2)
``` Java
@Configuration
@EnableSwagger2
public class SwaggerConfig {
	
	@Bean
	public Docket api() {
		return new Docket(DocumentationType.SWAGGER_2);
	}
}
```

That's it:
- go to localhost:8080/v2/api-docs, you'll see the documentation in JSON
- go to localhost:8080/swagger-ui.html, you'll see a formatted pretty view for the documentation.

This can be used to share the app's specs with customers, you can share the JSON and they can view it.

<<< LEFTOVER: This will be expanded later >>>

#### Filtering
What is filtering? <br/>
If we request the list of Users and we want to get some specific details about them only, we filter out any other details to get the details we want.

**Static Filtering** <br/>
This is an approach where we specify what to filter in the code itself.
- To do this, go to the User class, annotate the field *birthday* with @JsonIgnore.
- Or, annotate the whole class with @JsonIgnoreProperties(value={"birthday"})
- Now go to localhost:8080/users, see the result.

**Dynamic Filtering** <br/>
Instead, we can create mapping rules to use to filter the results.
Also, we can do that specific to web services, in one of the methods of the controller.

We'll use two classes:
- SimpleBeanPropertyFilter: a class used to filter properties.
- FilterProvider: this is a holder for different filters, so we can make many SimpleBeanPropertyFilter instances and pass all of them to the filterProvider, then apply all of them on the result.
- MappinJacksonValue: this class is used to apply filters on the bean we want.

**In Code** <br/>
First:
- Go to the User class
- Annotate it with @JsonFilter("myFilter")

Then:
- Go to UserResource
- Go to the method getUser
- Create a SimpleBeanPropertyFilter variable "filter"
- Assign it to SimpleBeanPropertyFilter.filterOutAllExcept(..), passing in the properties you want to include i.e. "name" and "id".
- Create a FilterProvider variable "filters"
- Use method addFilter(), passing in two things:
	+ the filter name we passed to @JsonFilter when we added this annotation to class User,
	+ the SimpleBeanPropertyFilter we created.
- Finally, create a MappingJacksonValue, in the constructor pass the User you retrieved.
- use method setFilters() on the MappingJacksonValue object, passin in the FilterProvider object.
``` Java
@GetMapping("/users/{id}")
	public EntityModel<User> getUser(@PathVariable int id) {
		User retrievedUser = userService.get(id);
		if(retrievedUser == null) {
			throw new UserNotFoundException("User of id: " + id + " not found.");
		}

		SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.filterOutAllExcept("id", "name");

		FilterProvider filters = new SimpleFilterProvider().addFilter("myFilter", filter);

		MappingJacksonValue mapping = new MappingJacksonValue(retrievedUser);

		mapping.setFilters(filters);
		
		EntityModel<User> resource = new EntityModel<>(retrievedUser);
		
		WebMvcLinkBuilder userLink = 
				WebMvcLinkBuilder.linkTo(
						WebMvcLinkBuilder
						.methodOn(this.getClass())
						.getAllUsers());
		
		resource.add(userLink.withRel("All Users"));
		
		return resource;
	}
```

Now go to localhost:8080/users, see the result :smile: <br/>

#### Connecting to an actual database
So far, we've used a list of Users with static data to represent data we get from a DB. <br/>
But now we'll actually use a DB and connect our app to it using JPA. <br/>

**Development Steps** <br/>
1. Add necessary dependencies.
2. Change the user class into an Entity.
3. 

**Step 1: Add necessary dependencies** <br/>
Add the dependencies:
- spring-boot-starter-data-jpa
- h2
to the POM file:
``` xml

```

**Step 2: Change the user class into an Entity** <br/>
- Go to class User.
- Annotate it with @Entity.
- Annotate the id field with:
	- @Id
	- @GeneratedValue(strategy=GenerationType.IDENTITY)
``` Java

```

## Best Practices for RESTful Services
### Basic Best Practices
**1. Consumer First** <br/>
What does your consumer want? <br/>
This is the main factor we should consider when designing web services.
- Make it easy for the user.
- Have GREAT documentation.

**2. Make The Best Use Of HTTP Methods** <br/>
Use the right method for your action, return the right response status or error accordingly.

**3. No Secure Info In URI** <br/>
**4. Use Nouns for Resources** <br/>
**5. Have A Consistent Approach, decide on a way of designing web services and use it across the whole project** <br/>

### Richardson Maturity Model
It's a way that helps us evaluate our RESTful web services as how "RESTful" are them.

There are four levels which we can rank our web services against:
1. Level 0: exposing SOAP web services in REST style, where our web services for example are:
	- http://server/getPosts
	- http://server/deletePosts
	etc.
	We are exposing ACTIONS on resources, not RESOURCES.
2. Level 1: exposing resources with proper URI, like this:
	- http://server/posts
	- http://server/posts/10
	However, in this level we aren't using HTTP methods properly.
3. Level 2: level 1 plus proper HTTP methods i.e. using DELETE, POST, GET, etc.

4. Level 3: level 2 plus HATEOAS i.e. exposing resources properly BUT ALSO giving the user info about what to do with the data they requested.

## Microservices With Spring Cloud
**So, what are microservices, and why are they invented?** <br/>
Microservices is a way of designing RESTful web services. <br/>

Basically *they are RESTful services that are divided into small parts where each part can be deployed and run on its own, and we can create new instances of each service and destroy old ones*.

So, it's like divining our application into small applications, one specifically for Adding users, one for Updating, one for Deleting, one for Reading, one for Getting all users, etc.

This makes it modular and can be easily extended.
Also, each service can now be built in a different technology, so we can add services using different technologies than Java like Node.js, Kotlin, etc.

BUT, there are some problems too:
- **Configuration management:** usually there is a centralized management code to manage all services, but since each service can run on its own and on a different environment, configuration becomes a nightmare xD
- **Visibility:** if a bug happens in one instance of one service in an app that consists of 50 microservices, it's harder to locate that bug, so we need to implement some monitoring logic.
- **Fault Tolerance:** some microservices call one another, so there are some services that are the base for all others, if these go down, the entire app goes down, so we have to have some fault tolerance in our services.

**Spring Cloud** <br/>
This is a Spring Project that provides tools to quickly build some of the common patterns of distributed systems.

***Note:*** A Spring Project is a part of Spring that adds some functionality for developers, it's like a small framework inside Spring, examples are Spring MVC, Spring REST, etc.

Spring Cloud consists of many other Spring Projects, each provides functionality and solutions for a specific problem, for example:
- **Spring Cloud Config Server**: provides an approach where we store all the configuration of all environment of all microservices in **one Git repo**, and can be exposed. (Solving the Configuration Management problem)
- **Netflix Eureka Naming Server**: this is a naming server where ANY instance of any service that is created, registers with the server, so we know how many instances of which services are created.
- **Ribbon**: this is used to dynamically balance load between microservice instances.
- **Feign**: this is used to write simple RESTful clients.
- **Eureka, Ribbon, and Feign** are used for load balancing between microservices.
- **Zipkin**: used to trace requests across components.
- **Netflix API Gateway** provide centralized logging, security, etc. part of it is **Zuul Gateway**.
- **Zipkin and Netflix API Gateway** are used for tracing errors (solving the Visibility problem)
- **Hystrix** this is used for fault tolerance.

**So what will we do?** <br/>
We'll create a new app, a Currency exchange app, using Microservices and Spring Cloud.
It will have these services:
- Limits service: it sets a limit to the quantity of currency to convert.
- Currency Exchange service: connects to DB and return the exchange value from a specific currency to another e.g. 1 USD to EUR.
- Currency Calculation service: uses Currency Exchange service to calculate exchange value from one currency to another, but with a quantity of the first currency e.g. 1000 USD to EUR.

**Standardizing ports and URLs** <br/>
Using Spring Cloud and Microservices usually means we'll use about 7 Spring projects, that is a lot xD

So, to keep things easy, we'll standardize ports like this:
- Limits Service: 8080, 8081, ...
- Spring Cloud Config Server: 8888
- Currency Exchange Service: 8000, 8001, 8002, ..
- Currency Conversion Service: 8100, 8101, 8102, ...
- Netflix Eureka Naming Server: 8761
- Netflix Zuul API Gateway Server: 8765
- Zipkin Distributed Tracing Server: 9411

And we'll standardize URLs like this:
- Limits Service: http://localhost:8080/limits POST -> http://localhost:8080/actuator/refresh
- Spring Cloud Config Server: http://localhost:8888/limits-service/default http://localhost:8888/limits-service/dev
- Currency Exchange Service: http://localhost:8000/currency-exchange/from/EUR/to/INR http://localhost:8001/currency-exchange/from/USD/to/INR
- Currency Conversion Service: 
	+ Direct call: http://localhost:8100/currency-converter/from/USD/to/INR/quantity/10
	+ Feign: http://localhost:8100/currency-converter-feign/from/EUR/to/INR/quantity/10000
- Netflix Eureka Naming Server: http://localhost:8761/
- Netflix Zuul API Gateway Server:  http://localhost:8765/currency-exchange-service/currency-exchange/from/EUR/to/INR http://localhost:8765/currency-conversion-service/currency-converter-feign/from/USD/to/INR/quantity/10
- Zipkin Distributed Tracing Server: http://localhost:9411/zipkin/
- Spring Cloud Bus Refresh: http://localhost:8080/bus/refresh

### Building a Currency Exchange App Using Microservices
We'll create our first Microservices app :smile: <br/>
Now, since they are Microservices, services divided in separate APPS, we'll use spring initializer to create our first Microservice: Limits service.

#### Our First Microservice
**In Code** <br/>
- Go to Spring Initializer
- Create this maven project:
	+ group: com.in28minutes.microservices
	+ artifact: limits-service
- Add these dependencies:
	+ Web
	+ Devtools
	+ Actuator
	+ Spring Cloud Config Client
- Download it, unzip it, and add it to the eclipse workspace you want.
- Open eclipse, import it as maven project.

So far, this is a normal Spring project, to make it a microservice we need to:
- Configure it accordingly
- Develop it as a RESTful service
- Connect it to Spring Cloud Config Server

**Starting Configuration** <br/>
- Add a name for the service and a port.
- Add this in the application.properties:
```
spring.application.name=limits-service
server.port=8080
```

**Creating the REST Controller** <br/>
- Create a new class LimitsConfigurationController, annotate it with @RestController.
- Inside it, create a method that returns an object of type LimitConfiguration, the method is called retrieveLimitsFromConfiguration.
- Annotate it with @GetMapping("/limits").
``` Java
@RestController
public class LimitsConfigurationController {

	@GetMapping("/limits")
	public LimitConfiguration retrieveLimitsFromConfiguration() {

		// empty for now
	}
}
```

**Creating te LimitConfiguration class** <br/>
- Create a new package com.in28minutes.microservices.limitsservice.bean
- Create a new class LimitConfiguration
- add two private fields:
	+ int maximum
	+ int minimum
- generate getters & setters.
- generate constructor using fields.
- add a no-arg constructor.
``` Java
public class LimitConfiguration {
	private int maximum;
	private int minimum;
	
	public LimitConfiguration() {
		
	}

	public LimitConfiguration(int maximum, int minimum) {
		super();
		this.maximum = maximum;
		this.minimum = minimum;
	}

	public int getMaximum() {
		return maximum;
	}

	public void setMaximum(int maximum) {
		this.maximum = maximum;
	}

	public int getMinimum() {
		return minimum;
	}

	public void setMinimum(int minimum) {
		this.minimum = minimum;
	}
}
```

We can try to return a hard coded LimitConfiguration object in the controller method:
``` Java
@RestController
public class LimitsConfigurationController {

	@GetMapping("/limits")
	public LimitConfiguration retrieveLimitsFromConfiguration() {
		return new LimitConfiguration(1000, 1);
	}
}
```
Run it and see the result at localhost:8080/limits to make sure everything is working. <br/>

**Enhancing the service to get maximum and minimum values from properties file** <br/>
- Add this to the properties file:
```
limits-service.minimum=99
limits-service.maximum=9999
```

How can we read these values using the service?
One way is dependency injection using @Value. <br/>
Another way is a Spring Boot annotation to save us some work: <br/>
- Crate a new class in com.in28minutes.microservices.limitsservice, called Configuration
- Annotate it with @Component and @ConfigurationProperties("limits-service"), we passed in the base name of the properties we'll read.
- inside it, add two private fields:
	+ int minimum
	+ int maximum
- generate getters and setters.
``` Java
@Component
@ConfigurationProperties("limits-service")
public class Configuration {
	private int minimum;
	private int maximum;
	public int getMinimum() {
		return minimum;
	}
	public void setMinimum(int minimum) {
		this.minimum = minimum;
	}
	public int getMaximum() {
		return maximum;
	}
	public void setMaximum(int maximum) {
		this.maximum = maximum;
	}
}
```

- Now go to LimitsConfigurationController
- Add a private field of type Configuration, annotate it with @Autowired.
- In the method retrieveLimitsFromConfiguration, change the hardcoded values and instead use the Configuration field's getters for maximum and minimum.
``` Java
@RestController
public class LimitsConfigurationController {

	@Autowired
	private Configuration configuration;

	@GetMapping("/limits")
	public LimitConfiguration retrieveLimitsFromConfiguration() {
		return new LimitConfiguration(configuration.getMaximum(), configuration.getMinimum());
	}
}
```
Go to localhost:8080/limits, see the result :smile: <br/>

Nice work :sunglasses: <br/>

#### Connecting Our Service To Spring Cloud Config Server
**Setting up the config server** <br/>
- Spring initializer:
	+ Group: com.in28minutes.microservices
	+ Artifact: spring-cloud-config-server
	+ Dependencies: Config Server, Devtools
- Add it to your workspace and open it in eclipse.
- Add to properties file:
```
spring.application.name=spring-cloud-config-server
server.port=8888
```

**Creating the Git repo that'll be used for central configuration by the Spring Cloud Config Server** <br/>
Spring Cloud Config Server provides a central place for configuration by specifying a git repo where we put all the config files.

First **Development Steps:**
- Download and Install git.
- Create a folder anywhere on your pc, call it git-localconfig-repo
- go into it, open a terminal there:
``` sh
$ git init
```

- Go to eclipse
- right-click on the project -> Build Path -> Link Source
- Browse to the folder we just created and click Select Folder.
- It will appear in the project tree
- Right-click on it and add a new file "limits-service.properties". It should have the application name of the microservice we're adding, in this case the Limits service "limits-service".
- In this file, take the limits-service.maximum and limits-service.minimum properties from the properties file of limits service to the new file in the git-localconfig-repo folder.
- Go to the terminal again:
``` sh
$ git add -A
$ git commit -m "any commit message you want"
```

**Connecting the Config server to the Git repo** <br/>
In the application.properties of the spring-cloud-config-server, add this:
```
spring.cloud.config.server.git.uri=file:///D:/Workspaces/microservices/git-localconfig-repo
```
Run the server app, go to localhost:8888/limits-service/default, see the result.

It will be an error 404 Not Found, why? <br/>
When we create a Spring Cloud Config Server, we need to Enable it, by:
- annotating the main app class of the server by @EnableConfigServer.
- then go to localhost:8888/limits-service/default again, see the result and the maximum & minimum values :smile:

*Real nice* :sunglasses: <br/>

**What if we want to store configuration for many environments?** <br/>
In our project we might have a development (DEV) environment, a testing (QA) environment and a production environments, each having their own properties, how do we handle that?

- Just Copy the file limits-service.properties and paste it twice with names:
	+ DEV: limits-service-dev.properties
	+ QA: limits-service-qa.properties
- Don't forget to git add and git commit.

Now, go to:
- localhost:8888/qa
- localhost:8888/dev
- localhost:8888/default
You should see the properties for each environment accordingly.

Easy peasy lemon squeezy :sunglasses:

**Connecting the Limits service to the Spring Cloud Config Server** <br/>
So far, we:
- Set up our config server app
- added a central git repo to it to use for configuration

Now, we want to connect Limits configuration to the config server app so that when we launch the service, it picks up the configuration values from the server.

To do that:
- rename the Limits service's application.properties to bootstrap.properties.
- add this to the bootstrap.properties file:
```
spring.cloud.config.uri=http://localhost:8888
```
and erase the minimum and maximum properties.

Now, start the service app, go to localhost:8080/limits, you'lll see the values that are in the limits-service.properties in the config server's repo :smile:

***Note:*** In the console output, you'll see "Fetching config from server at http://localhost:8888", then it'll say if it was a success or failure.

**Now, we've created our first microservice, we'll add more services** <br/>

Our app will consist of three microservices:
- Limits service.
- Currency Exchange service.
- Currency Calculation service.

#### Making the Currency Exchange Service
First, creating the app:
- Spring initializer:
	+ Group: com.in28minutes.microservices
	+ Artifact: currency-exchange-service
	+ Dependencies: Web, Devtools, Actuator, Config Client
- Add it to your workspace and open it in eclipse.
- Add to properties file:
```
spring.application.name=currency-exchange-service
server.port=8000
```

Then, create a new class:
- called ExchangeValue.
- fields:
	+ int id.
	+ String from.
	+ String to.
	+ int conversionMultiple.
- no arg constructor. 
- constructor using fields.
- getters & setters.
``` Java
public class ExchangeValue {
	private int id;
	private String from;
	private String to;
	private int conversionMultiple;
	
	public ExchangeValue() {
		
	}

	public ExchangeValue(int id, String from, String to, int conversionMultiple) {
		super();
		this.id = id;
		this.from = from;
		this.to = to;
		this.conversionMultiple = conversionMultiple;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getFrom() {
		return from;
	}

	public void setFrom(String from) {
		this.from = from;
	}

	public String getTo() {
		return to;
	}

	public void setTo(String to) {
		this.to = to;
	}

	public int getConversionMultiple() {
		return conversionMultiple;
	}

	public void setConversionMultiple(int conversionMultiple) {
		this.conversionMultiple = conversionMultiple;
	}
}
```

Then, making the app into a service:
- Create a Rest controller class CurrencyExchangeController
- add a method retrieveExchangeValue.
	+ return type: ExchangeValue
	+ arguments: String from, String to, both annotated by @PathVariable
	+ @GetMapping("/currency-exchange/from/{from}/to/{to}")
- For now, return a hardcoded ExchangeValue object.
``` Java
@RestController
public class CurrencyExchangeController {
	
	@GetMapping("/currency-exchange/from/{from}/to/{to}")
	public ExchangeValue retrieveExchangeValue(@PathVariable String from, @PathVariable String to) {
		return new ExchangeValue(1, from, to, 65);
	}
}
```
Go to localhost:8000/currency-exchange/from/USD/to/EUR, see the result :smile:

**Calling a service from a service** <br/>
The currency calculation service should call the currency exchange service.
Also, we would need to create different instances of the currency exchange service, we need to determine which instance will the currency calculation call.

To do this, we'll use the PORT as a unique identifier for each instance.

This means that each instance of the currency exchange service should hold the port value, so we'll need to add the field to the class.

***Note:*** This isn't the best practice, but it'll be good for now.

Step 1:
- add an int field port to class ExchangeValue and generate getters & setters for it.
- In the CurrencyExchangeController, add a private field of type Environment, annotate it with @Autowired. (Environment is an already defined type in Spring)
- In the method retrieveExchangeValue, use exchangeValue.setPort(), inside pass environment.getPropert("local.server.port"), the return is a string so use Integer.parseInt() to convert it to int.
``` Java
@RestController
public class CurrencyExchangeController {
	
	@Autowired
	private Environment environment;
	
	@GetMapping("/currency-exchange/from/{from}/to/{to}")
	public ExchangeValue retrieveExchangeValue(@PathVariable String from, @PathVariable String to) {
		ExchangeValue exchangeValue = new ExchangeValue(1, from, to, 65);
		exchangeValue.setPort(
				Integer.parseInt(
						environment.getProperty(
								"local.server.port"
								)
						)
				);
		return exchangeValue;
	}
}
```
Go to http://localhost:8000/currency-exchange/from/USD/to/EUR, check the port number :smile:

<<< LEFTOVER: Dynamic ports video -> starting different instances of the same service in Eclipse >>>

<<< LEFTOVER: Create database and connect using JPA >>>

#### Making the Currency Calculation Service
First, creating the app:
- Spring initializer:
	+ Group: com.in28minutes.microservices
	+ Artifact: currency-conversion-service
	+ Dependencies: Web, Devtools, Actuator, Config Client
- Add it to your workspace and open it in eclipse.
- Add to properties file:
```
spring.application.name=currency-conversion-service
server.port=8100
```

Second, create a new class CurrencyConversionBean:
- fields:
	+ int id
	+ String from
	+ String to
	+ int conversionMultiple
	+ int requestedQuantity
	+ int calculatedAmount;
- getters and setters
- no arg contructor
- constructor using fields
``` Java
public class CurrencyConversionBean {
	private int id;
	private String from;
	private String to;
	private int conversionMultiple;
	private int quantity;
	private int conversionAmount;
	private int port;
	
	public CurrencyConversionBean() {
		
	}
	
	public CurrencyConversionBean(int id, String from, String to, int conversionMultiple, int quantity,
			int conversionAmount, int port) {
		super();
		this.id = id;
		this.from = from;
		this.to = to;
		this.conversionMultiple = conversionMultiple;
		this.quantity = quantity;
		this.conversionAmount = conversionAmount;
		this.port = port;
	}

	

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getFrom() {
		return from;
	}

	public void setFrom(String from) {
		this.from = from;
	}

	public String getTo() {
		return to;
	}

	public void setTo(String to) {
		this.to = to;
	}

	public int getConversionMultiple() {
		return conversionMultiple;
	}

	public void setConversionMultiple(int conversionMultiple) {
		this.conversionMultiple = conversionMultiple;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public int getConversionAmount() {
		return conversionAmount;
	}

	public void setConversionAmount(int conversionAmount) {
		this.conversionAmount = conversionAmount;
	}

	public int getPort() {
		return port;
	}

	public void setPort(int port) {
		this.port = port;
	}
}
```

Second, create a controller similar to the one in CurrencyExchange:
``` Java
@RestController
public class CurrencyConversionController {
	
	@Autowired
	private Environment environment;
	
	@GetMapping("/currency-converter/from/{from}/to/{to}/quantity/{quantity}")
	public CurrencyConversionBean convertCurrency(
			@PathVariable String from,
			@PathVariable String to,
			@PathVariable int quantity
			) {
		CurrencyConversionBean conversionBean = 
				new CurrencyConversionBean(1, from, to, 65, quantity, quantity * 65, 0);
		
		conversionBean.setPort(
				Integer.parseInt(
						environment.getProperty(
								"local.server.port"
								)
						)
				);		
		return conversionBean;
	}
}
```

This service will call the Currency Exchange service to get data from it.

**How do we do that?** <br/>
By using RestTemplate.

- In the controller, in the method convertCurrency, create a local variable of type 
- assign it to RestTemplate().getForEntity("http://localhost:8000/currency-exchange/from/{from}/to/{to}", CurrencyConversionBean.class), passing in the uri of the service we want to call, the type of the response we expect, and a map of the uri arguments' values.
- This returns ResponseEntity<CurrencyConversionBean>, use .getBody to get the CurrencyConversionBean object and assign it to a new local variable "response".
- Make a new CurrencyConversionBean, in the constructor use:
	- response.getId()
	- from
	- to
	- response.getConversionMultiple()
	- quantity
	- response.getConversionMultiple() * quantity
	- 0
- set the port of the new CurrencyCoversionBean object to the port of the environment, like we did in Currency Exchange.
- Return that.
``` Java

@RestController
public class CurrencyConversionController {
	
	@Autowired
	private Environment environment;
	
	@GetMapping("/currency-converter/from/{from}/to/{to}/quantity/{quantity}")
	public CurrencyConversionBean convertCurrency(
			@PathVariable String from,
			@PathVariable String to,
			@PathVariable int quantity
			) {
		
		Map<String, String> uriVariables = new HashMap<>();
		
		uriVariables.put("from", from);
		uriVariables.put("to", to);
		
		
		ResponseEntity<CurrencyConversionBean> forEntity = new RestTemplate().getForEntity(
				"http://localhost:8000/currency-exchange/from/{from}/to/{to}"
				, CurrencyConversionBean.class
				, uriVariables);
		
		CurrencyConversionBean response = forEntity.getBody();
		
		CurrencyConversionBean conversionBean = new CurrencyConversionBean(
				response.getId(),
				from,
				to,
				response.getConversionMultiple(),
				quantity,
				quantity * response.getConversionMultiple(), 
				response.getPort()
			);
		
		return conversionBean;
	}
}
```
Now run that service (make sure the config server and the currency exchange service are both already running), then go to http://localhost:8100/currency-converter/from/USD/to/EUR/quantity/10, then change the quantity argument to 20, see if it changes :smile:

***Rip in pepperonies*** :sunglasses: <br/>

### Using Spring Cloud Features To Solve Microservices Design Problems

#### Using Feign to Call Othe Services
We managed to call a service from another service, but we wrote a lot of code to do one service call.

Usually in projects there are 10s and sometimes 100s of services and lots of them call each other, that would be a coding nightmare.

To solve this, we can use a Spring Cloud solution called Feign.

First, add the dependency to the POM file of currency conversion service:
``` xml
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

Second, enable Feign:
- Annotate the main app of currency conversion service with @EnableFeignClients("com.in28minutes.microservices.currencyconversionservice"), passing in the base package to scan for Feign clients.

To use Feign, we need to create a Feign Proxy to talk to other services (the same idea as the repository to talk to the DB).
- Create a new package com.in28minutes.microservices.currencyconversionservice.proxy
- Create a new interface CurrencyExchangeServiceProxy
- Annotate it with @FeignClient(name="currency-exchange-service", url="localhost:8000"), passing in the name of the service we'll call (from the service's bootstrap.properties file), and its url .
- Inside it, define a method retrieveExchangeValue:
	+ return type: CurrencyConversionBean
	+ Annotated with @GetMapping("/currency-exchange/from/{from}/to/{to}")
	+ Arguments: String from, String to, annotated with @PathVariable
``` Java
@FeignClient(
		name="currency-exchange-service",
		url="localhost:8000")
public interface CurrencyExchangeServiceProxy {
	
	@GetMapping("/currency-exchange/from/{from}/to/{to}")
	public CurrencyConversionBean getExchangeValue(@PathVariable("from") String from, @PathVariable("to") String to);
}
```

Now, in CurrencyConversionController instead of all we did before, just use exchangeProxy.getExchangeValue().
``` Java
@GetMapping("/currency-converter/from/{from}/to/{to}/quantity/{quantity}")
	public CurrencyConversionBean convertCurrency(
			@PathVariable String from,
			@PathVariable String to,
			@PathVariable int quantity
			) {

		CurrencyConversionBean response = exchangeProxy.getExchangeValue(from, to);
		
		return new CurrencyConversionBean(
				response.getId(),
				from,
				to,
				response.getConversionMultiple(),
				quantity,
				quantity * response.getConversionMultiple(), 
				response.getPort()
			);
	}
```
Finally, go to http://localhost:8100/currency-converter/from/USD/to/EUR/quantity/10, change the quantity to 20, see the change :smile:

#### Using Ribbon to handle Load Balancing
**What is load balancing?** <br/>
Applications that are designed in Microservices have a good advantage in that they can be easily used in distributed systems.

Several microservices can communicate with each other on several computers, each microservice can have different instances.

But, suppose that 170 people log on to Youtube, and Youtube is designed in microservices, this means that 170 instances of the microservice that brings the homepage will start.

170 instances! That is a Lot of instances!
And of course, if we're talking about Youtube, then 170 is a tiny number, typically there are much more people using youtube every second.

So, how does the server handle all this work?
- First of all, a giant corporation like Youtube probably doesn't have "a" server, it has hundreds of servers in huge clusters just to process data (fun fact, these huge clusters are called *Render Farms*)
- Also, the most efficient use of all those servers is to somehow divide the work needed to be done on the servers such that they are near each other in the level of work they're handling.

So if a server is already working on something, it's assigned little additional work, if a server is idle, it's assigned a lot of work.

This process is called *Load Balancing*, and it is one of the problems we face when designing microservices.

**In our example** <br/>
If we have ONE instance of the conversion service, but FOUR instances of the exchange service, we would want to distribute the the conversion service's exchange service calls between the four instances of the exchange service.

We'll use Spring Cloud's solution: *Ribbon*.

First of all, let's add the dependency to the POM fle of the conversion service:
``` xml
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
</dependency>
```

Then, enable Ribbon on the proxy interface:
- Go to the CurrencyExchangeServiceProxy interface.
- Add this annotation @RibbonClient(name="currency-exchange-service").
- Now, remove the URL argument from the @FeignClient annotation:
``` Java
@FeignClient(name="currency-exchange-service")
@RibbonClient(name="currency-exchange-service")
public interface CurrencyExchangeServiceProxy {
	
	@GetMapping("/currency-exchange/from/{from}/to/{to}")
	public CurrencyConversionBean getExchangeValue(@PathVariable("from") String from, @PathVariable("to") String to);
}
```
Why did we remove the url argument from @FeignClient?
- The URL specified a specific port for a specific exchange service instance.
- But now, we'll use Ribbon to distribute calls between different instances, so we shouldn't specify a url because Ribbon will distribute the calls on all instances of exchange service.

Now, let's run two instances of the exchange service:
- First instance: Run it on 8000, the normal way.
- Second instance: In Eclipse, click on the arrow beside the Run button (green arrow) -> Run Configuration:
	+ In the tree, right-click on CurrencyExchangeServiceApplication8000 -> duplicate.
	+ Change the new one's name to CurrencyExchangeServiceApplication8001.
	+ Go to the arguments tab, in the VM arguments add this:
	``` sh
	-Dserver.port=8001
	```


At the same time, we want to give Ribbon a list of the instances so that it can switch between them, we do that in the bootstrap.properties file.

Add this to the properties file:
```
currency-exchange-service.ribbon.listOfServers=http://localhost:8000,http://localhost:8001
```

Now, launch the conversion service, try refreshing and seeing the port change :smile: <br/>

#### Eureka! Wait what?
Well, what we did last time wasn't really *convenient*, think about it, we need to add something to the properties file for EVERY instance of the exchange service.

If we're talking about a big project with lots of services, that is just *impossible* and not practical.

So how can we solve this?
Eureka! that's what Archimedes said when he discovered bouyancy. <br/>
And that's the name for the Spring Cloud solution for this problem.

A *naming server* is a server that translates IP addresses into domain names, so that instead of using IP addresses to call services, we can use domain names.

Thanks to naming servers, we don't have to type 8.8.8.8 every time we want to search something, we just have to type the domain name of the service whose IP address is 8.8.8.8.
You know what that domain name is? it's *google* :smile: <br/>

That's what a naming server does, it *names* services. <br/> 

Eureka is a naming server provided by Netflix for Spring Cloud, any service instance created registers with Eureka so that Eureka gives it a name.

So, whenever the service needs to be called, the name is used instead of the IP address, and Ribbon can use this to dynamically know the list of instances to balance the load across, instead of hardcoding it into the properties file.

Creating the Eureka server:
- Spring initializer:
	+ Group: com.in28minutes.microservices
	+ Artifact: netflix-eureka-naming-server
	+ Dependencies: Eureka Server, Config Client, Actuator, Devtools
- download it, import it, etc.

Now, using it:
- First, enable it by going to its main app and annotating it with @EnableEurekaServer
- Go to its properties:
```
spring.application.name=netflix-eureka-naming-server
server.port=8761

# this here because we don't want this app to register with eureka server, because it IS the eureka server..
eureka.client.register-with-eureka=false
eureka.client.fetch-registry=false
```
- Run the main app.

Adding eureka dependency to the conversion service:
- Go to the conversion service's POM file and add the dependency:
``` xml
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-eureka</artifactId>
</dependency>
```

Enabling conversion service to be discovered by Eureka:
- Go to the conversion service's main app and annotate it with @EnableDiscoveryClient.
- Go to the properties file of the service and add this:
```
eureka.client.service-url.default-zone=http://localhost:8761/eureka
```

Now go to http://localhost:8761, you'll see a fancy UI for Spring Cloud Eureka, check the *instances currently registered* section :smile:

We are awesome :sunglasses: <br/>

Do the same with the exchange service and the Limits service.

**But how do we tell Ribbon to use these names given by Eureka?** <br/>
Just disable the listOfServers property, that's it xD <br/>

Try it, remove that line from the conversion service's properties file, then start two instances of the exchange service, then start the conversion service (check in eureka's UI that all is registered), go to http://localhost:8100/currency-converter/from/USD/to/EUR/quantity/10, refresh it and see the port change :smile:

***Note:*** allow a little bit of time for Eureka to warm up (about 20 seconds to 1 minute). <br/>

### Using Spring Cloud Zuul for Cross-Cutting Logic
**What about cross-cutting logic?** <br/>
In big projects with hundreds of microservices talking to each other, we would want some things to apply on all services before or after or during their execution, like authentication, authorization, security, call limits, etc.


**What if a user requested a service that called 17 other services?** <br/>
It's better to *aggregate* those services into one service call, than call 18 services.

This is called *Service Aggregation*.

**How do we apply *Cross-Cutting Logic* and *Service Aggregation* in our microservices app?** <br/>
This is done by changing things a little:
- Instead of services directly calling each other, they go through a Gateway, an *API Gateway*.
- This *API Gateway* is responsible for applying cross-cutting logic, service aggregation, and making sure things go right if there are problems i.e. fault tolerance.
- Also, it's a good place to debug and do analytics on the code.

**How do we make an API Gateway in Spring?** <br/>
Netflix provides a solution in Spring Cloud, called *Zuul*.

**Development Steps:**
1. Create a component for *Zuul*, with the right dependencies.
2. Implement the logic applied on every call.
3. Configuring all calls to go through the *Zuul* API Gateway.

**Step 1** <br/>
- Spring initializer:
	+ Group: the same one as before, I'm lazy.
	+ Artifact: netflix-zuul-api-gateway-server
	+ Dependencies: Zuul, Eureka Discovery (because we'll register Zuul to Eureka too), Actuator, Devtools.
- Import it to eclipse.
- Go to the new project's main app and annotate it with @EnableZuulProxy.
- Also, register with Eureka i.e. annotate it with @EnableDiscoveryClient.
- Go to the properties file and configure the name and port:
```
spring.application.name=netflix-zuul-api-gateway-server
server.port=8765
eureka.client.service-url.default-zone=http://localhost:8761/eureka
```

**Step 2** <br/>
We'll add some logging, so that any request that comes through the gateway, we'll just log it.
- In the zuul project, add a new package: com.in28minutes.microservices.netflixzuulapigatewayserver.filters
- Create a new class ZuulLoggingFilter, it extends ZuulFilter.
- Annotate it with @Component.
- hover over the name (should have an error) and click *add umimplemented methods*.
- There are four methods:
	+ **ShouldFilter**: should this filter be applied or not?
	+ **run**: the actual logic that'll be applied on request calls that pass through the gateway.
	+ **filterType**: when should it happen? (before request "pre", after request "post", only on error requests "error")
	+ **filterOrder**: if we have different filters, what is the priority of this filter relative to others? (lowest number = highest priority)
``` Java
@Component
public class ZuulLoggingFilter extends ZuulFilter {

	private Logger logger = LoggerFactory.getLogger(this.getClass());

	@Override
	public boolean shouldFilter() {
		return true;
	}

	@Override
	public Object run() {
		// we want to log the current request details
		// so, first we'll get them and put them in
		// an HttpServletRequest local object
		HttpServletRequest request = RequestContext.getCurrentContext().getRequest();

		// then, we'll use the Logger to log the details
		// of the request, for example its URI
		logger.info("request -> {} request uri -> {}", request, request.getRequestURI());

		return null;
	}

	@Override
	public String filterType() {
		return "pre"; // i.e. before the request
	}

	@Override
	public int filterOrder() {
		return 0;
	}

}
```
- Make sure that Eureka is running.
- Start an exchange service.
- Start a conversion service.
- Now, run the Zuul main app.
- Check that Eureka registered Zuul and the other services..

***Note:*** things may get slow now because of performance, depending on your PC's specs. <br/>

**Step 3** <br/>
So, how do we make a request go through the Zuul API gateway?
- The url for the gateway is: http://localhost:8765/
- To make a service call go through it, the url should be http://localhost:8765/{application-name}/{uri} where application-name is the service name, and the {uri} is the uri of the service.
- For example, in the case of exchange service, it should be:
http://localhost:8765/currency-exchange-service/currency-exchange/from/USD/to/EUR
- Try this in the browser, see the response.
- Now, look at the console output, you'll see the contents of the request printed out.

**That's doing it directly, we want to route the conversion service's calls to exchange service through the gateway**
- The thing that actually makes the call is the currency exchange service proxy, provided by Feign.
- And we're already registering everyting with Eureka.
- So, we need to want to make Feign connect not to the service directly, but to the gateway itself.
- Also, the URI now is changed, the application name is appended to it.
- So, go to the conversion service app, in the interface CurrencyExchangeServiceProxy, change the annotation @FeignClient's argument name's value:
``` Java
@FeignClient(name="netflix-zuul-api-gateway-server")
```
- Inside it, change the @GetMapping's value to add the application's name to the URL from the start:
``` Java
@GetMapping("/currency-exchange-service/currency-exchange/from/{from}/to/{to}")
```
- Here's the interface after changes:
``` Java
@FeignClient(name="netflix-zuul-api-gateway-server")
@RibbonClient(name="currency-exchange-service")
public interface CurrencyExchangeServiceProxy {
	
	@GetMapping("/currency-exchange-service/currency-exchange/from/{from}/to/{to}")
	public CurrencyConversionBean getExchangeValue(@PathVariable("from") String from, @PathVariable("to") String to);
}
```

Now, refresh the conversion service's URL in the browser http://localhost:8100/currency-converter/from/USD/to/EUR/quantity/10

Notice that this is the normal url.
Look at the logs, see the output of Zuul to check that the exchange service's call is routed through Gateway.

### Distributed Tracing
How do we find bugs in a microservice application?
We have only three services but we're already going into some complex things.
So how do we solve this?

We want a single centralized location where we can see a complete chain of what happened within a specific request.

This is called *Distributed Tracing*.

There are options to do this *distributed tracing*, one of them is a Spring Cloud solution called ***Zipkin***.

One idea is to assign a unique ID to each request so that we can trace it across the application, a Spring Cloud solution called ***Sleuth*** does that.

But, to do that, we need to put all the logs from all the services in a queue, this queue feeds to *Zipkin* server, where it's consolidated, and we can look through different requests and trace them.

For that, we'll need yet another Spring Cloud solution, ***RabbitMQ***.

Recap:
- ***Zipkin***: to trace requests, we can search requests by ID, this ID will be assigned by ***Sleuth***.
- ***Sleuth***: adds unique ID to each request so that we can trace it.
- ***RabbitMQ***: stores the request logs in a queue so that *Zipkin* can use them.

**Development Steps:**
1. Adding Sleuth:
	1. Add Spring Cloud Sleuth dependency to Zuul, the conversion service and the exchange service. 
	2. Create a bean method that returns a Sampler, in the three's main apps (zuul, conversion service, exchange service).
2. Adding Zipkin:
	1. Adding RabbitMQ.
	2. Adding Zipkin.

**Step 1: Adding Sleuth** <br/>
**Step 1.1** <br/>
- Add this to the POM file of the Zuul server.
``` xml
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>
```
- Do the same for conversion and exchange services.

**Step 2.2** <br/>
In each of zuul, conversion service, exchange service, add this to the main app:
- Add a new method:
	+ return type: Sampler
	+ name: defaultSampler()
``` Java
@Bean
public Sampler defaultSampler() {
	return Sampler.ALWAYS_SAMPLE;
}
```
- Restart the three applications.

**Step 2: Adding RabbitMQ** <br/>
**Step 2.1** <br/>
- Go to https://www.rabbitmq.com/install-windows.html.
- Before installing RabbitMQ, we'll need to install ***Erlang***, it's a runtime environment for RabbitMQ, you'll find the link on the same page.
- Download the Erlang version appropriate for your OS and 64 or 32-bit.
- Install Erlang.
- Then go back to the rabbitMQ page and download rabbitMQ.
- Install RabbitMQ, by default it would be running in the background as a service.
- 


***Note:*** For windows users, you can run Zipkin server from the cmd:
``` sh
$ set RABBIT_URI=amqp://localhost
$ java -jar zipkin-server-2.7.0-exec.jar
```




### Fault Tolerance with Spring Cloud Hystrix
**What is fault tolerance?** <br/>
In big projects with hundreds of microservices talking to each other, some services might fail, some problems might happen, and if our entire system fails because of one of these problems, that won't be a very good thing.

If youtube's app collapses because one user requested something that made an error, it would stay off all the time, you know xD

So, we have to account for this when designing our app, we want our app to continue operating in the best way possible in case of problems, errors, etc.

This is called *Fault Tolerance*. <br/>