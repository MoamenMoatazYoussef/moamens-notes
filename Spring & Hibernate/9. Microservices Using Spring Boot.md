# Microservices Using Spring Boot
## Table of Contents
## Tips

## Introduction
**What is a web service anyway?** <br/>
A formal definition of a web service is a "service" that is communicated over the web.

**What's a simpler way to say it?**<br/>
When you open your PC, and you open Youtube, what appears to you is the homepage of Youtube with recommended videos, your subscriptions' videos, etc.

What happened between you and the PC is that you opened youtube.
What happened between your PC and the Youtube server may be much more.

For example, the Youtube server may request your username and password, so your PC sends them over.

If you search youtube for something, that string you wrote in the search bar is send by your PC to the server, where the server searches and does a lot of stuff, before getting a list of videos that match your search string, and sends them back, where they are rendered on your PC to look like the list we know today.

The server requested your user & pass.
Your PC requested a list of things that match a string.
The server sent a list of things that match that string.

So, we can say that Youtube offers a search service for users.
The communication between your PC and Youtube is in the form of requests, responses, etc.

These are "Services" between your PC and the server, over the internet.

That is a *Web service*.

A *Web service* is a piece of software that runs on a computer, and offers to run some software logic, or *"service"* to other computers, communicating with each other over some network.

Web services are:
- designed to be communicated between machines, PCs, computers, **applications running on computers**, not human beings (Yes, you type the search string and press enter, but your PC does all the work from that point on).
- are communicated over a Network, be it the internet or any other network.
- not platform dependent, ANY machine in the world should be able to send Youtube servers search requests.

**How does PCs or applications send and receive data to and from each other?** <br/>
Your PC and the Youtube server are connected, but to get search results:
- Your PC needs to tell the server "I want videos that match this string". This is called a *Request*.
- The server does its logic.
- The server tells your PC "I got the videos you requested, here it is", this message is sent to your PC along with the list of videos. This is called a *Response*.

This means, that for a web service to be platform independent (one of its properties we said earlier), the format of Requests and Responses should not depend on the sending pc or receiving server's specifications.

So, the formats of Requests and Responses should be standardized.

The two standard formats for Requests and Responses are:
1. XML: eXtensible Marup Language, this can be generated from any application on any PC, whether the application is a Java app, a PHP app, etc.

Also this can be sent by any PC, be it the Titan Supercomputer or a nokia 6600.

2. JSON: JavaScript Object Notation, same thing, can be sent by any application on any PC.

**So how does your PC or the server know the format?** <br/>
When your PC and the server are connected, they sign a contract between each other, this contract specifies:
- the **format** that is used by Requests and Responses,
- the **structure of the request** that the PC should send to the server,
- the **structure of the response** that should be expected by your PC, and
- the **endpoint** of the service, *what URL should I use to request the service?*.

This contract is called a *Service Definition*.

The format used by Requests and Responses is called the *Message Exchange Format*.

Your PC is a *service consumer*, it Consumes the service offered by the server.

The Youtube server is the *service provider*, it hosts the service and listens for requests by any connected PC.

**How are web services called through their endpoints?**
Endpoint: the URL of the service that your PC uses to send a request to the server.

Your PC is using the internet to do that, it's using *HTTP requests* to call that service.

There is another way for web services, a **Queue**.
- Service consumer places a message on the queue.
- Service provider listens to the queue, 
- as soon as it gets the message from the queue, it takes the request, do the logic, creates the response, then puts it in the queue,
- the service consumer listens to the queue, until it gets the response.

So, web services are communicated through:
- HTTP, over the internet.
- MQ, over queues in the network.

This is called *transport*.

**Recap** <br/>
- Your PC connects to the server.
- Your PC and the server sign a contract, a *service definition*, that specifies how the web service is offered to your PC.
- You search for a string and press enter.
- Your PC reads the *service definition* to know what *message exchange format* the web service expects.
- Then, your PC takes your string, along with other data, and organizes it in the format specified by the *service definition*.
- Your PC then reads the *service definition* to know what is the *endpoint* of the service, how can we reach that service.
- Your PC then uses that *endpoint* to call the service, since this is the internet, the service is called in a specific way, a *transport*, called HTTP.

### Types of Web Services
Web services are divided into two types:
- SOAP.
- REST.

**Wait what?**
Basically, XML is a markup language, it's a format, but it doesn't specify a specific **structure** of a message.

Therefore, there is a standard structure written in XML for web services, this is called a *Simple Object Access Protocol*, or *SOAP*.

*SOAP* is a specific XML structure that is used by web services, it consists of three main parts:
- **Header:** this doesn't contain your actual message, it contains data needed by the two machines to communicate with each other, like authentication, authorization, etc.
- **Body:** this is where you put your actual message, the search string is put here.
- **Envelope:** an element that is wrapper for the whole message, it contains the Header and the Body.

Messages that are structured in a SOAP structure, or *SOAP messages*, can be sent through any type of *transport* i.e. HTTP or MQ (Queues).

**Service Definition in SOAP** <br/>
Remember the contract signed by your PC and the youtube server? the *service definition*.

If your PC and the server communicate using *SOAP messages*, the *service definition* is written in an XML-based language, called *Web Service Definition Language* or *Web Service Description Language*, or just **WSDL**.

**There is another type of web services, specific to HTTP transport** <br/>

HTTP messages actually consist of several parts:
1. HTTP body: the message send by your PC or the server.
2. HTTP Method: this indicates what you want to do with the data:
    - GET: you want the server to fetch you some data.
    - POST: you want to add some new data in the server.
    - PUT: you want to update some existing data in the server.
    - DELETE: you want to remove some existing data from the server.
3. HTTP Status Code: this indicates the status of the service call, for example:
    - 200: this means that the call was successful.
    - 404: this means that what you requested was not found (I know you've seen this error before xD)

Web services should be designed to use all three parts of HTTP in order to communicate effectively

To fill all HTTP parts, a web service must adhere to some constraints, these constraints are grouped together in a software architecture called *REpresentational State Transfer* or *REST*.

Web services that are designed according to *REST* concepts are called *RESTful* web services.

**What are the *REST* constraints that web services should adhere to?** <br/>
- When we say a "Resource", we mean anything that you want to expose to the world using your app, for example the videos on youtube, the list of videos itself, etc.
- Each one of these videos **must be identified** by something that is unique, a *Unique Resource Identifier*, a *URI*.
- Since web services should be compatible with HTTTP, they **must support** all HTTP methods i.e. they should support:
    + Creation of data (POST).
    + Fetching of data (GET).
    + Updating of data (PUT).
    + Deletion of data (DELETE).

So, a *RESTful* web service must:
- Have a *Unique Resource Identifier*, a *URI*.
- Support all HTTP methods.

***Note:*** Unlike SOAP, *REST* doesn't care about the format of your message, be it XML, JSON, etc., it defines how this message is communicated across the network.

RESTful web services don't have a standard *service definition* language like SOAP, which has *WSDL*.

But, there are definitions for RESTful web services, like WADL and Swagger, here we'll use Swagger.

In this course, we'll use web services in Spring Boot.

## RESTful Web Services with Spring Boot

### Creating Simple RESTful Services
To develop a RESTful Web Service, we have to specify:
    - What kind of request is it? (GET, POST, etc.)
    - What is its URI?

So what are we going to do now? <br/>
We have a list of users, each user creates posts.

This means that the relationship between User and Post is one-to-many.

Also, posts can't exist without users.
Therefore, when we retrieve posts, we'll have to specify a user. (Not a *must* requirement in the real world, but we'll use it to specify URIs for each service)

We will create RESTful web services, mainly the four main requests:
- Get the entire list of users:
    + GET request.
    + URI: /users.
- Create a user: 
    + POST request.
    + URI: /users.
- Get a single user: 
    + GET request,.
    + URI: /users/{id} where {id} is the id of the user we want.
- Delete a single user: 
    - DELETE request.
    -  URI: /users/{id}.

Also, we'll create web services for posts by users:
- Retrieve all posts for a user:
    + GET.
    + /users/{id}/posts
- Create a post for a user:
    + POST.
    + /users/{id}/posts
- Retrieve details for a post:
    + GET.
    + /users/{id}/posts/{post_id}

Finally, we'll focus on:
    - Validation,
    - Internationalization.
    - Exception handling.
    - Versioning services,
    - and other things.

**Prep for our first project** <br/>
First, we'll create a new Spring Boot project:
- Go to Spring Initializer: https://start.spring.io/
- Create a new project:
    - Maven
    - Spring anything greater than 2.2.0 snapshot.
    - Coordinates:
        - groupId: com.in28minutes.rest.webservices
        - artifactId: restfulwebservices
    - Dependencies:
        - Spring web
        - Devtools
        - JPA
        - H2
- Generate the project.
- Import it as an Existing Maven Project to Eclipse.
- Wait until Eclipse downloads the dependencies.
- Go to the main class in src/main/java and run the app as a Java application.
- Go to a browser and open localhost:8080 to check that the app is running successfully.

#### First Steps
**Hello World RESTful Web Service** <br/>
- Create a new package "com.in28minutes.rest.webservices.controller".
- In it, create a new class HelloWorldController.
- Instead of @Controller, annotate it with @RestController, this annotation tells Spring that this class will handle REST requests.
- To create a REST service, we need to define:
    + What method,
    + URI.
- For our first service, we'll use method GET and URI /hello-world.
- Create a new method that returns a String "hello-world".
- Annotate the method with @RequestMapping, passing in the method to "method" argument, and the URI to "path" argument, or just annotate it with @GetMapping.
``` Java
@RestController
public class HelloWorldController {

	@GetMapping(path="/hello-world")
	public String HelloWorld() {
		return "Hello World";
	}
}
```
Run the app, then open localhost:8080/hello-world in a browser, see the output :)

**Creating an bean and returning it** <br/>
Instead of returning a string, we'll try to return a Bean, an Object that has a string field inside it.
- Create a similar method, HelloWorldBean.
- Map it to /hello-world-bean
- change the return type to HelloWorldBean.
- return new HelloWorldBean("Hello World Bean").
- An error will show because HelloWorldBean isn't defined yet, create a new class HelloWorldBean.
- Add a private string field "message",
- Add getters & setters for it.
- Add a constructor setting the message field.
- Add a toString method.
``` java
public class HelloWorldBean {
	private String message;

	public HelloWorldBean(String message) {
		super();
		this.message = message;
	}

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

	@Override
	public String toString() {
		return "HelloWorldBean [message=" + message + "]";
	}
}
```
Go back to the browser, then open localhost:8080/hello-world-bean in a browser, see the output :)

***Note:*** This will display an error if we don't create a getter for the field message.

**So what's happening in the background?** <br/>
Spring Boot does some auto-configuration, it configures many objects like:
- **dispatcherServlet**: this is the class responsible for taking incoming URIs, mapping them to the right methods in Controller classes, and mapping the output of those methods to view pages.
- **HttpMessageConverters**: these are classes responsible for transforming beans to JSON and vice versa, an example class is Jackson2ObjectMapper.

So, Spring Boot autoconfigures all of that stuff, then when we go to localhost:8080/hello-world-bean:
1. This URI goes to dispatcherServlet.
2. dispatcherServlet searches @RestController(s) for methods that map to this URI, and determines that the method HelloWorldBean maps to the URI /hello-world-bean.
3. This method is executed and returns a bean.
4. The original @RestController interface has an annotation @ResponseBody, this makes the response from any class annotated by @RestController be converted to some other format by one of the HttpMessageConverters.
5. So, the returned bean goes into one of the HttpMessageConverters and is converted to a JSON object that can be displayed.
6. Then, dispatcherServlet determines the view page that will return with the output.
7. Finally, the selected view page is returned and viewed on the browser.

**Adding Path variable to the mapping** <br/>
All the URIs we mapped so far were hardcoded by us. What if we want to map something that changes?
- In Eclipse, in the HelloWorldController class, create a new method, similar to the previous ones.
- In the @GetMapping or @RequestMapping annotation in the path argument, make it "/hello-world-bean/path-variable/{name}".
- In the method signature, add a String argument called "name", the same as in the path argument.
- Before it, put an annotation @PathVariable, so that this argument gets mapped to the path argument in the @GetMapping annotation.
- Inside the method itself, you can put the name argument in the string of the bean.
``` Java
@GetMapping(path="/hello-world-bean/path-variable/{name}")
public HelloWorldBean HelloWorldBean(@PathVariable String name) {
	return new HelloWorldBean("Hi, " + name);
}
```

Now, go to localhost:8080/hello-world-bean/path-variable/<any name you want>, try different names, every time you should see a JSON object containing the name :) <br/>

This type of path variable will be used extensively.

#### Creating the Entity Class
Now, we'll add the User class and services necessary for the User.

***Note:*** for now, we'll store User objects in an arrayList, after a while we'll use JPA to store them in a DB. 

**Step 1** <br/>
- Create a new package "com.in28minutes.rest.webservices.restfulwebservices.entity".
- In it, create a new class User.
    - int id
    - String name
    - Date birthday
    - getters and setters
    - constructor using fields
    - toString
``` Java
public class User {
	private int id;
	private String name;
	private Date birthday;
	
	public User(int id, String name, Date birthday) {
		super();
		this.id = id;
		this.name = name;
		this.birthday = birthday;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Date getBirthday() {
		return birthday;
	}

	public void setBirthday(Date birthday) {
		this.birthday = birthday;
	}

	@Override
	public String toString() {
		return "User [id=" + id + ", name=" + name + ", birthday=" + birthday + "]";
	}
}
```

**Step 2** <br/>
- Create a new package "com.in28minutes.rest.webservices.restfulwebservices.dao"
- In it, create a new generic interface BaseDAO<T>:
    - method: get users
    - method: get one user by id
    - method: save user
    - method: delete user by id
``` Java
public interface BaseDAO<T> {
	public List<T> findAll();
	
	public T get(int id);
	
	public T save(T t);
	
	public void delete(int id);
}
```

**Step 3** <br/>
- Create a new interface UserDAO that implements BaseDAO<User>:
    - static list<User>
    - static int to hold the number of users in the list.
    - static block, init some users.
    - method: get users: return the list.
    - method: get one user by id: get one from the list.
    - method: save user: save user to the list or update if existing.
    - method: delete user by id: remove a user from the list.
- for now annotate it with @Component (after that we'll change that to @Repository when we use JPA).
``` Java
@Component
public class UserDAO implements BaseDAO<User> {
	private static List<User> users = new ArrayList<>(); //TODO: replace with DB
	
	private static int usersCount = 4; //TODO: replace with DB
	
	static { //TODO: replace with DB
		users.add(new User(1, "Max", new Date()));
		users.add(new User(2, "Payne", new Date()));
		users.add(new User(3, "Mona", new Date()));
		users.add(new User(4, "Sax", new Date()));
	}
	
	@Override
	public List<User> findAll() {
		return users;
	}

	@Override
	public User get(int id) {
		for(User user: users) {
			if(user.getId() == id) {
				return user;
			}
		}
		return null;
	}

	@Override
	public User save(User t) {
		if(t.getId() == null) {
			t.setId(++usersCount);
		}
		users.add(t);
		return t;
	}

	@Override
	public void delete(int id) {
		for(User user: users) {
			if(user.getId() == id) {
				users.remove(user);
				return;
			}
		}
	}

}
```

**Optional Step** <br/>
- Create a new package "com.in28minutes.rest.webservices.restfulwebservices.service"
- In it, create a new generic interface BaseService<T>:
    - method: get users
    - method: get one user by id
    - method: save user
    - method: delete user by id
``` Java
public interface BaseService<T> {
	public List<T> findAll();
	
	public T get(int id);
	
	public T save(T t);
	
	public void delete(int id);
}
```

- Create a new interface UserService that implements BaseService<User>.
- add a private BaseDAO<User>, @Autowired.
- Create these methods:
    - findAll()
    - get(int id)
    - save(User t)
    - delete(int id)
    All of these methods call the respective method using the BaseDAO<User> object.

- for now annotate it with @Component (after that we'll change that to @Service when we use JPA).
``` Java
@Component
public class UserDAO implements BaseDAO<User> {
	private static List<User> users = new ArrayList<>(); //TODO: replace with DB
	
	private static int usersCount = 4; //TODO: replace with DB
	
	static { //TODO: replace with DB
		users.add(new User(1, "Max", new Date()));
		users.add(new User(2, "Payne", new Date()));
		users.add(new User(3, "Mona", new Date()));
		users.add(new User(4, "Sax", new Date()));
	}
	
	@Override
	public List<User> findAll() {
		return users;
	}

	@Override
	public User get(int id) {
		for(User user: users) {
			if(user.getId() == id) {
				return user;
			}
		}
		return null;
	}

	@Override
	public User save(User t) {
		if(t.getId() == null) {
			t.setId(++usersCount);
		}
		users.add(t);
		return t;
	}

	@Override
	public void delete(int id) {
		for(User user: users) {
			if(user.getId() == id) {
				users.remove(user);
				return;
			}
		}
	}

}
```

**Step 4** <br/>
- In the controller package, create a new Controller "UserResource".
- Annotate it with @RestController.
- Add a private field of BaseDAO<User> (or BaseService<User> if you did the optional step), annotate it with @Autowired.
- Create methods to do this:
    - retrieve all users.
    - retrieve user by id.
``` Java
@RestController
public class UserResource {
	
	@Autowired
	public BaseService<User> userService;

	@GetMapping("/users")
	public List<User> getAllUsers() {
		return userService.findAll();
	}
	
	@GetMapping("/users/{id}")
	public User getUser(@PathVariable int id) {
		return userService.get(id);
	}
}
```
Now go to localhost:8080/users, you should see json objects containing all the users.
Try to go to localhist:8080/users/2, see that the only user 2 is displayed.

Nice :) <br/>


#### Saving Entities
Okay, so how do we save users?
By using a POST request, to the URI of the DB of users (in our case so far, a list), the URI is /users.

If you open Chrome Dev Tools (F12 or right-click -> inspect), go to the network tab, you can see the HTTP requests and responses.

In GET requests, Spring MVC responses with an HTTP status code: 200 OK, which means "Successful Request".

In POST requests, we want to get a different status code which means "Created", and the response should return the newly created user's URI.

**In Code** <br/>
- Go to eclipse, in the Controller class UserResource.
- Create a new method "createUser" or "saveUser", which has a User argument.
- Annotate it with @PostMapping("/users"), passing in the URI of the users list.
- Annotate the User argument of the method with @RequestBody, this annotation means that the POST request will have a body that contains a User object (that is because we'll send a user to be created).
- Inside the method, just use the service to save the User argument and return the User object returned.
``` Java
@RestController
public class UserResource {
	
	@Autowired
	public BaseService<User> userService;

	@GetMapping("/users")
	public List<User> getAllUsers() {
		return userService.findAll();
	}
	
	@GetMapping("/users/{id}")
	public User getUser(@PathVariable int id) {
		return userService.get(id);
	}
	
	// here it is
	@PostMapping("/users")
	public User saveUser(@RequestBody User user) {
		return userService.save(user);
	}
}
```
**Now, how do we send POST requests?** <br/>
To send POST reviews, we'll use a chrome extension called Postman, go to chrome and install it.

In Postman, enter the url localhost:8080/users, choose POST request, then go to the tab Body, inside it put a JSON object with "name" and "birthday" fields and values.

Now, when you click *Send*, you'll encounter an error "Internal Server Error", that is because we don't have a no-arg constructor for the entity we're trying to add, which is User.

Add a no-arg constructor to User and try sending again with Postman.

You'll see status code 200 OK, now go reload localhost:8080/users, you'll see the new user with an automatically created ID :) <br/>

Real nice :) <br/>

Well...not "real nice", because we want the status CREATED, not the status OK..

Also, we didn't return the created user in the response.

Can we return the status CREATED and put the created user in the response?

**Yes** <br/>
We want to do two things:
1. Return the status code CREATED.
2. Return the newly created user's URI.

To do that, we'll use a Spring object called ResponseEntity<T>, we'll call its method .created(), this method will return the status code CREATED.

This method also takes an argument "location", which is the URI of the new user, to be returned with the status CREATED.

So, inside this method we should pass the URI of the new user.

How do we get the URI of the new user?
By using another Spring object called ServletUriComponentsBuilder, this object has several methods we'll use.

First of all, we need the URI to be /users/{id} i.e. we need to append the id of the new User object to the current request URI /users.

So:
1. we'll use the method .fromCurrentRequest() to start from the current request URI, then 
2. we'll use .path("/{id}") to append the /{id} to the current request URI, then
3. we'll use the method .buildAndExpand(newUserObject.getId()) to pass the new id to the parameter {id}, finally
4. we'll use the method .toUri() to get the resulting Uri of the newly created user. 

**In Code** <br/>
- Go to UserResource class, to the method we just created.
- Instead of returning the User object, save it in a local variable "savedUser".
- Create a new local variable of type URI called location (or anything, I just called it location).
- Assign it to ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(savedUser.getId()).toUri();

Then,
- return ResponseEntity.created(location).build();
This build the response with the status code CREATED and the URI of the newly created user, which is our objective.
- Finally, change the method return type to RequestEntity<Object>.
``` Java

@RestController
public class UserResource {
	
	@Autowired
	public BaseService<User> userService;

	@GetMapping("/users")
	public List<User> getAllUsers() {
		return userService.findAll();
	}
	
	@GetMapping("/users/{id}")
	public User getUser(@PathVariable int id) {
		return userService.get(id);
	}
	
	// That was a lot of work right there xD
	@PostMapping("/users")
	public ResponseEntity<Object> saveUser(@RequestBody User user) {
		User savedUser = userService.save(user);
		
		URI location = ServletUriComponentsBuilder
				.fromCurrentRequest()
				.path("/{id}")
				.buildAndExpand(savedUser.getId())
				.toUri();
		
		return ResponseEntity.created(location).build();
	}
}
```
Now go to Postman, create a new user and send a POST request, check the status: 201 CREATED.

Go to the Headers tab, there's a field Location, which has the location of the newly created user.

Now that, is *Real nice* :) <br/>

#### Exception Handling - User Not Found
Try sending a GET request for a user that doesn't exist e.g. id = 500, from postman.

The response will surprose you:
Status: 200 OK.
Body: empty.

That's not right xD <br/>
If user isn't found, we shouldn't return a status OK, we should show an error indicating that this user doesn't exist.

Well, we can throw an error, but there is no specific error for users not found.

So, we'll have to create our own error to throw (yeah we're kind of psychos, we create our own errors xD)

**In Code** <br/>
- Create a new package "com.in28minutes.rest.webservices.restfulwebservices.myerrors"
- Create a new class UserNotFoundException that extends RuntimeException.

That would be enough since we have the capabilities of RuntimeException, but we can add some more by overriding the constructor by providing a message constructor.

- Create a constructor that overrides RuntimeException(String message).
- inside it, just use super(message).
``` Java
public class UserNotFoundException extends RuntimeException {

	public UserNotFoundException(String message) {
		super(message);
	}
	
}
```

Now, go back to the controller UserResource, modify the getUser function like this:
``` Java
@GetMapping("/users/{id}")
public User getUser(@PathVariable int id) {
	User retrievedUser = userService.get(id);
	if(retrievedUser == null) {
		throw new UserNotFoundException("User of id: " + id + " not found.");
	}
	return retrievedUser;
}
```

If we do a GET request using Postman now, we'll get 500 Internal Server Error.

That's...good, but not quite good, that is NOT a server error.

We need to return a response status that says that the user is not found.

To do that, annotate the UserNotFoundException with:
``` Java
@ResponseStatus(HttpStatus.NOT_FOUND)
```

Try the request again, you'll get status 404 Not Found (We are the one causing this error now, told you we are psychos xD)

The response body will have a structure provided by Spring that is a standard structure for exceptions.

Now that is really good :) <br/>

It's important to return the appropriate exception message in the response.
So, it's better to define a standard exception structure that you always follow when creating exceptions for web services.

***Note:*** the exception structure is usually standardized across the entire Organization.

**How do we create an Exception structure and override the standard one?** <br/>
- Create a new class ExceptionResponse.
- in it, we'll add the fields:
	- Date, to indicate when the error happened.
	- String, message.
	- String, details.

- Add a constructor using all fields.
- Generate getters and setters.
``` Java
public class ExceptionResponse {
	private Date timestamp;
	private String message;
	private String details;
	public ExceptionResponse(Date timestamp, String message, String details) {
		super();
		this.timestamp = timestamp;
		this.message = message;
		this.details = details;
	}
	
	public Date getTimestamp() {
		return timestamp;
	}
	public void setTimestamp(Date timestamp) {
		this.timestamp = timestamp;
	}
	public String getMessage() {
		return message;
	}
	public void setMessage(String message) {
		this.message = message;
	}
	public String getDetails() {
		return details;
	}
	public void setDetails(String details) {
		this.details = details;
	}
}
```

In Spring, there's an abstract class called ResponseEntityExceptionHandler, this can be extended to provide centralized exception handling for all our requests.

To make other exceptions conform to this structure, we'll extend this and implement our own exception handling functionality.

**In Code** <br/>
- Create a new class CustomizedResponseEntityExceptionHandler that extends ResponseEntityExceptionHandler.
- Annotate it with @RestController, because it provides responses back.
- Also, annotate it with @ControllerAdvice, this is an anootation that indicates that this class declares methods to be shared across classes.
- Now, to override the default exception handling, add a public final method, which returnes ResponseEntity<Object> called handleUserNotFoundException, taking two arguments of type Exception and WebRequest.
- Inside it, create an instance of our new exception structure ExceptionResponse using the constructor with fields.
	+ Get a new date
	+ Use the Exception argument to get the exception message
	+ Use the request to get the description and pass it to the details.
- Assign this to a local ExceptionResponse variable.
- Return a new ResponsEntity that takes two arguments in its constructor, the first is your exceptionResponse, the second is an httpStatus.
- Finally, annotate it with @ExceptionHandler, this indicates that the method annotated will be used to handle any exception whose class is passed to the annotation.
- Pass UserNotFoundException.class to the annotation to make this method handle any exception of type UserNotFoundException.
``` java
@ControllerAdvice
@RestController
public class CustomResponseEntityExceptionHandler extends ResponseEntityExceptionHandler {
	
	@ExceptionHandler(UserNotFoundException.class)
	public final ResponseEntity<Object> handleUserNotFoundException(Exception e, WebRequest request) {
		ExceptionResponse myResponse = new ExceptionResponse(
				new Date(), 
				e.getMessage(), 
				request.getDescription(false));
		
		return new ResponseEntity<Object>(myResponse, HttpStatus.NOT_FOUND);
	}
}
```

***Note:*** if you want this method to handle all exceptions, then pass Exception.class to the annotation instead of UserNotFoundException.class.

Now perform a new get request, see the structure of the error message :) <br/>

#### Deleting A User
That's a DELETE request, we'll use Postman to send it.
Well, we'll remove the user whose id is passed.
To do that we'll use a list iterator. (In the future, we'll delete it from the database)

We can return 200 OK status back, we can also return a status of "No Content".

**In Code** <br/>
- In the UserDAO, in the delete method, use an iterator to traverse the list and find the desired User, then remove it from the list and return it.
``` Java
	@Override
	public User delete(int id) {
		Iterator<User> it = users.iterator();
		
		while(it.hasNext()) {
			User user = it.next();
			if(user.getId() == id) {
				it.remove();
				return user;
			}
		}
		return null;
	}
```

***Note:*** you'll have to change the return type, also the return type of the method in the generic interface, the method in the generic service interface, and the method in UserService.

Then, 
- in the UserResource controller, add a new method deleteUser that takes int id as argument.
- Annotate it with @DeleteMapping("/users")
- Annotate the argument with @PathVariable.
- Use service to delete the user and get it.
- Throw a UserNotFoundException if user isn't found.
- [Optional] Use ResponseEntity's method .noContent.
``` Java
	@DeleteMapping("/users/{id}")
	public ResponseEntity<Object> delete(@PathVariable int id) {
		User user = userService.delete(id);
		if(user == null) {
			throw new UserNotFoundException("User of id: " + id + " not found.");
		}
		
		return ResponseEntity.noContent().build();
	}
```
Try deleting an existing user and check localhost:8080/users, then try deleting a non-existing user and check the response in Postman.

Nice :) <br/>

#### User Field Validation
Alright, so we implemented the CRUD services for User entity.
That's good, but we haven't validated any one of the User fields.
When we create a new user, we want to validate the user.

There are some javax.validation API annotations we'll use:
- @Valid: this means we want to validate this, we'll annotate the User argument in the controller method.
- @Size: this takes attributes to specify how big/small the input of that is, applied on the String name field of User.
- @Past: this indicates that the Date object should be in the past relative to the system time, applied on the Date birthday field of User. 

That's the controller method after adding @Valid:
``` Java
	@PostMapping("/users")
	public ResponseEntity<Object> saveUser(@Valid @RequestBody User user) {
		User savedUser = userService.save(user);
		
		URI location = ServletUriComponentsBuilder
				.fromCurrentRequest()
				.path("/{id}")
				.buildAndExpand(savedUser.getId())
				.toUri();
		
		return ResponseEntity.created(location).build();
	}
```

This is the User class after using @Size and @Past:
``` Java

public class User {
	private Integer id;
	
	@Size(min=2)
	private String name;
	
	@Past
	private Date birthday;

	...
}
```
Try sending POST responses to create users, but with name whose size is 1 or birthday which is in the future. You'll get status 400 Bad Request.

That's good, validation is working, but we need to deliver the specific error description.

We did that before, so we'll do something similar.

Remember the class ResponseEntityExceptionHandler? This class has a method handleMethodArgumentNotValud, this method is fired when a binding to a method argument fails i.e. Validation error.

So, we'll override this method in our CustomResponseEntityExceptionHandler class.
- Go to CustomResponseEntityExceptionHandler.
- Implement a new method protected ResponseEntity<Object> handleMethodArgumentNotValud(MethodArgumentNotValidException ex).
- Inside it, create a new ExceptionResponse, passing in a new Date(), ex.getMessage(),  
- and ex.getBindingResult().toString(), which has details of what went wrong.
- return a new ResponseEntity, passing in the ExceptionResponse object and HttpStatus.BAD_REQUEST.
``` Java
	@Override
	protected ResponseEntity<Object> handleMethodArgumentNotValid(
			MethodArgumentNotValidException ex, 
			HttpHeaders headers, 
			HttpStatus status, 
			WebRequest request) {
		ExceptionResponse myResponse = new ExceptionResponse(
				new Date(), 
				ex.getMessage(), 
				ex.getBindingResult().toString());
		
		return new ResponseEntity<Object>(myResponse, HttpStatus.BAD_REQUEST);
	}
```
***Note:*** Arguments in this method may differ due to different versions of Spring.

Try creating a user with invalid fields, see the error message now :) <br/>

You can even add a customized message for each field validation, for example:
- in the User object, in @Size, add an argument message="Name should have at least two characters".

Try creating a user again, see the error message.

***Get on my level*** :sunglasses: <br/>

***Note:***
- Check the javax.validation API for much more validation and error handling rules.
- Check the documentation of class ResponseEntityExceptionHandler to see how you can customize error and exception handling.
- Check Hibernate Validator, the most common validation handler used with Spring.

